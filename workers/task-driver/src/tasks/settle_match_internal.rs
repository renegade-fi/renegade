//! A task akin to `settle_match`, but on a match that was generated by the
//! internal matching engine

use std::error::Error;
use std::fmt::{Display, Formatter, Result as FmtResult};

use crate::task_state::StateWrapper;
use crate::traits::{Task, TaskContext, TaskError, TaskState};
use crate::utils::order_states::{record_order_fill, transition_order_settling};
use crate::utils::validity_proofs::{
    enqueue_proof_job, find_merkle_path_with_tx, update_wallet_validity_proofs,
};
use alloy::rpc::types::TransactionReceipt;
use ark_mpc::{PARTY0, PARTY1};
use async_trait::async_trait;
use circuit_types::r#match::MatchResult;
use circuits::zk_circuits::proof_linking::link_sized_commitments_match_settle;
use circuits::zk_circuits::valid_match_settle::{
    SizedValidMatchSettleStatement, SizedValidMatchSettleWitness,
};
use common::types::price::{TimestampedPrice, TimestampedPriceFp};
use common::types::proof_bundles::{MatchBundle, ProofBundle, ValidMatchSettleBundle};
use common::types::tasks::SettleMatchInternalTaskDescriptor;
use common::types::wallet::{OrderIdentifier, WalletIdentifier};
use common::types::{
    proof_bundles::{OrderValidityProofBundle, OrderValidityWitnessBundle},
    wallet::Wallet,
};
use constants::Scalar;
use darkpool_client::DarkpoolClient;
use darkpool_client::errors::DarkpoolClientError;
use job_types::event_manager::{EventManagerQueue, FillEvent, RelayerEventType, try_send_event};
use job_types::network_manager::NetworkManagerQueue;
use job_types::proof_manager::{ProofJob, ProofManagerQueue};
use renegade_metrics::helpers::record_match_volume;
use serde::Serialize;
use state::State;
use state::error::StateError;
use tokio::task::JoinHandle as TokioJoinHandle;
use tracing::{Instrument, instrument};
use util::err_str;
use util::matching_engine::{
    compute_fee_obligation, compute_max_amount, settle_match_into_wallets,
};
use util::on_chain::get_protocol_fee;

use super::ERR_AWAITING_PROOF;

// -------------
// | Constants |
// -------------

/// The name of the task
pub const SETTLE_MATCH_INTERNAL_TASK_NAME: &str = "settle-match-internal";

/// Error message emitted when a wallet cannot be found
const ERR_WALLET_NOT_FOUND: &str = "wallet not found in global state";

// --------------
// | Task State |
// --------------

/// The state of the settle match internal task
#[derive(Clone, Debug, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum SettleMatchInternalTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is proving `VALID MATCH SETTLE` as a singleprover circuit
    ProvingMatchSettle,
    /// The task is submitting the match transaction
    SubmittingMatch,
    /// The task is updating the wallet state and Merkle openings
    UpdatingState,
    /// The task is updating validity proofs for the wallet
    UpdatingValidityProofs,
    /// The task has finished
    Completed,
}

impl TaskState for SettleMatchInternalTaskState {
    fn commit_point() -> Self {
        Self::SubmittingMatch
    }

    fn completed(&self) -> bool {
        matches!(self, Self::Completed)
    }
}

impl From<SettleMatchInternalTaskState> for StateWrapper {
    fn from(value: SettleMatchInternalTaskState) -> Self {
        Self::SettleMatchInternal(value)
    }
}

impl Display for SettleMatchInternalTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Pending => write!(f, "Pending"),
            Self::ProvingMatchSettle => write!(f, "Proving Match Settle"),
            Self::SubmittingMatch => write!(f, "Submitting Match"),
            Self::UpdatingState => write!(f, "Updating State"),
            Self::UpdatingValidityProofs => write!(f, "Updating Validity Proofs"),
            Self::Completed => write!(f, "Completed"),
        }
    }
}

// ---------------
// | Task Errors |
// ---------------

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchInternalTaskError {
    /// Error enqueuing a job with another worker
    EnqueuingJob(String),
    /// State necessary for execution cannot be found
    MissingState(String),
    /// Error re-proving wallet and order validity
    ProvingValidity(String),
    /// Error interacting with darkpool client
    Darkpool(String),
    /// A wallet is already locked
    WalletLocked(WalletIdentifier),
    /// An error interacting with the global state
    State(String),
    /// An error sending an event to the event manager
    SendEvent(String),
}

impl TaskError for SettleMatchInternalTaskError {
    fn retryable(&self) -> bool {
        matches!(self, Self::ProvingValidity(_) | Self::Darkpool(_) | Self::State(_))
    }
}

impl Display for SettleMatchInternalTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}
impl Error for SettleMatchInternalTaskError {}

impl From<StateError> for SettleMatchInternalTaskError {
    fn from(err: StateError) -> Self {
        Self::State(err.to_string())
    }
}

impl From<DarkpoolClientError> for SettleMatchInternalTaskError {
    fn from(err: DarkpoolClientError) -> Self {
        Self::Darkpool(err.to_string())
    }
}

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match internal task
pub struct SettleMatchInternalTask {
    /// The price at which the match was executed
    execution_price: TimestampedPriceFp,
    /// The identifier of the first order
    order_id1: OrderIdentifier,
    /// The identifier of the second order
    order_id2: OrderIdentifier,
    /// The identifier of the first order's wallet
    wallet_id1: WalletIdentifier,
    /// The identifier of the second order's wallet
    wallet_id2: WalletIdentifier,
    /// The validity proofs for the first order
    order1_proof: OrderValidityProofBundle,
    /// The validity proof witness for the first order
    order1_validity_witness: OrderValidityWitnessBundle,
    /// The validity proofs for the second order
    order2_proof: OrderValidityProofBundle,
    /// The validity proof witness for the second order
    order2_validity_witness: OrderValidityWitnessBundle,
    /// The match result
    match_result: MatchResult,
    /// The proof of `VALID MATCH SETTLE` generated in the first task step
    match_bundle: Option<MatchBundle>,
    /// The transaction receipt of the match settlement
    tx: Option<TransactionReceipt>,
    /// The darkpool client to use for submitting transactions
    darkpool_client: DarkpoolClient,
    /// A sender to the network manager's work queue
    network_sender: NetworkManagerQueue,
    /// A copy of the relayer-global state
    state: State,
    /// The work queue to add proof management jobs to
    proof_queue: ProofManagerQueue,
    /// The state of the task
    task_state: SettleMatchInternalTaskState,
    /// A sender to the event manager
    event_queue: EventManagerQueue,
}

#[async_trait]
impl Task for SettleMatchInternalTask {
    type State = SettleMatchInternalTaskState;
    type Error = SettleMatchInternalTaskError;
    type Descriptor = SettleMatchInternalTaskDescriptor;

    async fn new(descriptor: Self::Descriptor, ctx: TaskContext) -> Result<Self, Self::Error> {
        let SettleMatchInternalTaskDescriptor {
            execution_price,
            order_id1,
            order_id2,
            wallet_id1,
            wallet_id2,
            order1_proof,
            order1_validity_witness,
            order2_proof,
            order2_validity_witness,
            match_result,
        } = descriptor;

        Ok(Self {
            execution_price,
            order_id1,
            order_id2,
            wallet_id1,
            wallet_id2,
            order1_proof,
            order1_validity_witness,
            order2_proof,
            order2_validity_witness,
            match_result,
            match_bundle: None, // Assuming default initialization
            tx: None,
            darkpool_client: ctx.darkpool_client,
            network_sender: ctx.network_queue,
            state: ctx.state,
            proof_queue: ctx.proof_queue,
            task_state: SettleMatchInternalTaskState::Pending, // Assuming default initialization
            event_queue: ctx.event_queue,
        })
    }

    #[allow(clippy::blocks_in_conditions)]
    #[instrument(skip_all, err, fields(
        task = self.name(),
        state = %self.state(),
        wallet_id1 = %self.wallet_id1,
        wallet_id2 = %self.wallet_id2,
    ))]
    async fn step(&mut self) -> Result<(), Self::Error> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMatchInternalTaskState::Pending => {
                self.task_state = SettleMatchInternalTaskState::ProvingMatchSettle
            },

            SettleMatchInternalTaskState::ProvingMatchSettle => {
                self.prove_match_settle().await?;
                self.task_state = SettleMatchInternalTaskState::SubmittingMatch
            },

            SettleMatchInternalTaskState::SubmittingMatch => {
                self.submit_match().await?;
                self.task_state = SettleMatchInternalTaskState::UpdatingState
            },

            SettleMatchInternalTaskState::UpdatingState => {
                self.update_state().await?;
                self.task_state = SettleMatchInternalTaskState::UpdatingValidityProofs
            },

            SettleMatchInternalTaskState::UpdatingValidityProofs => {
                self.update_proofs().await?;
                self.emit_events()?;
                record_match_volume(
                    &self.match_result,
                    false, // is_external_match
                    &[self.wallet_id1, self.wallet_id2],
                );

                self.task_state = SettleMatchInternalTaskState::Completed;
            },

            SettleMatchInternalTaskState::Completed => {
                panic!("step called on completed task")
            },
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_INTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMatchInternalTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone()
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMatchInternalTask {
    // --------------
    // | Task Steps |
    // --------------

    /// Prove `VALID MATCH SETTLE` on the order pair
    async fn prove_match_settle(&mut self) -> Result<(), SettleMatchInternalTaskError> {
        let (witness, statement) = self.get_witness_statement();

        // Enqueue a job with the proof generation module
        let job = ProofJob::ValidMatchSettleSingleprover { witness, statement };
        let proof_recv = enqueue_proof_job(job, &self.proof_queue)
            .map_err(SettleMatchInternalTaskError::EnqueuingJob)?;

        // Await the proof from the proof manager
        let bundle = proof_recv.await.map_err(|_| {
            SettleMatchInternalTaskError::EnqueuingJob(ERR_AWAITING_PROOF.to_string())
        })?;

        // Create proof links between the parties' proofs of `VALID COMMITMENTS` and the
        // `VALID MATCH SETTLE` proof
        let match_bundle = self.create_link_proofs(bundle)?;
        self.match_bundle = Some(match_bundle);
        Ok(())
    }

    /// Submit the match transaction
    async fn submit_match(&mut self) -> Result<(), SettleMatchInternalTaskError> {
        // Transition both orders to the `SettlingMatch` state
        transition_order_settling(self.order_id1, &self.state)
            .await
            .map_err(SettleMatchInternalTaskError::State)?;
        transition_order_settling(self.order_id2, &self.state)
            .await
            .map_err(SettleMatchInternalTaskError::State)?;

        // Submit a `match` transaction
        let tx = self
            .darkpool_client
            .process_match_settle(
                &self.order1_proof,
                &self.order2_proof,
                self.match_bundle.as_ref().unwrap(),
            )
            .await?;
        self.tx = Some(tx);
        Ok(())
    }

    /// Update the wallet state and Merkle openings
    async fn update_state(&self) -> Result<(), SettleMatchInternalTaskError> {
        // Nullify orders on the newly matched values
        let nullifier1 = self.order1_proof.reblind_proof.statement.original_shares_nullifier;
        let nullifier2 = self.order2_proof.reblind_proof.statement.original_shares_nullifier;
        self.state.nullify_orders(nullifier1).await?;
        self.state.nullify_orders(nullifier2).await?;

        // Transition the orders to the `Filled` state if necessary
        let price: TimestampedPrice = self.execution_price.into();
        record_order_fill(self.order_id1, &self.match_result, price, &self.state)
            .await
            .map_err(SettleMatchInternalTaskError::State)?;
        record_order_fill(self.order_id2, &self.match_result, price, &self.state)
            .await
            .map_err(SettleMatchInternalTaskError::State)?;

        // Lookup the wallets that manage each order
        let mut wallet1 = self.find_wallet(&self.wallet_id1).await?;
        let mut wallet2 = self.find_wallet(&self.wallet_id2).await?;

        // Update wallets from the shares after settlement
        let match_bundle = self.match_bundle.as_ref().unwrap();
        let party0_public_shares = &match_bundle.match_proof.statement.party0_modified_shares;
        let party0_private_shares =
            &self.order1_validity_witness.reblind_witness.reblinded_wallet_private_shares;
        let party1_public_shares = &match_bundle.match_proof.statement.party1_modified_shares;
        let party1_private_shares =
            &self.order2_validity_witness.reblind_witness.reblinded_wallet_private_shares;
        wallet1.update_from_shares(party0_private_shares, party0_public_shares);
        wallet2.update_from_shares(party1_private_shares, party1_public_shares);

        self.find_opening(&mut wallet1)?;
        self.find_opening(&mut wallet2)?;

        // Re-index the updated wallets in the global state
        let waiter1 = self.state.update_wallet(wallet1).await?;
        let waiter2 = self.state.update_wallet(wallet2).await?;
        waiter1.await?;
        waiter2.await?;

        Ok(())
    }

    /// Update validity proofs for the wallet
    async fn update_proofs(&self) -> Result<(), SettleMatchInternalTaskError> {
        // Lookup wallets to update proofs for
        let wallet1 = self.find_wallet(&self.wallet_id1).await?;
        let wallet2 = self.find_wallet(&self.wallet_id2).await?;

        // We spawn the proof updates in tasks so that they may run concurrently, we do
        // not want to wait for the first wallet's proofs to finish before
        // starting the second wallet's proofs when the proof generation module
        // is capable of handling many at once
        let t1 = Self::spawn_update_proofs_task(
            wallet1,
            self.proof_queue.clone(),
            self.state.clone(),
            self.network_sender.clone(),
        );
        let t2 = Self::spawn_update_proofs_task(
            wallet2,
            self.proof_queue.clone(),
            self.state.clone(),
            self.network_sender.clone(),
        );

        // Await both threads and handle errors
        let (res1, res2) = tokio::join!(t1, t2);
        let res1 =
            res1.unwrap().map_err(|e| SettleMatchInternalTaskError::ProvingValidity(e.to_string()));
        let res2 =
            res2.unwrap().map_err(|e| SettleMatchInternalTaskError::ProvingValidity(e.to_string()));

        res1.and(res2)
    }

    // -----------
    // | Helpers |
    // -----------

    /// Find the wallet for an order in the global state
    async fn find_wallet(
        &self,
        wallet_id: &WalletIdentifier,
    ) -> Result<Wallet, SettleMatchInternalTaskError> {
        self.state.get_wallet(wallet_id).await?.ok_or_else(|| {
            SettleMatchInternalTaskError::MissingState(ERR_WALLET_NOT_FOUND.to_string())
        })
    }

    /// Get the witness and statement for `VALID MATCH SETTLE`
    fn get_witness_statement(
        &self,
    ) -> (SizedValidMatchSettleWitness, SizedValidMatchSettleStatement) {
        let commitment_statement0 = &self.order1_proof.commitment_proof.statement;
        let commitment_statement1 = &self.order2_proof.commitment_proof.statement;
        let commitment_witness0 = &self.order1_validity_witness.commitment_witness;
        let commitment_witness1 = &self.order2_validity_witness.commitment_witness;

        let price = self.execution_price.price();
        let order0 = commitment_witness0.order.clone();
        let balance0 = commitment_witness0.balance_send.clone();
        let balance_receive0 = commitment_witness0.balance_receive.clone();
        let relayer_fee0 = commitment_witness0.relayer_fee;

        let order1 = commitment_witness1.order.clone();
        let balance1 = commitment_witness1.balance_send.clone();
        let balance_receive1 = commitment_witness1.balance_receive.clone();
        let relayer_fee1 = commitment_witness1.relayer_fee;

        // Compute the fees owed by each party in the match
        let party0_fees = compute_fee_obligation(relayer_fee0, order0.side, &self.match_result);
        let party1_fees = compute_fee_obligation(relayer_fee1, order1.side, &self.match_result);

        // Apply the match to the secret shares of the match parties
        let party0_indices = commitment_statement0.indices;
        let party0_public_shares = commitment_witness0.augmented_public_shares.clone();
        let party1_indices = commitment_statement1.indices;
        let party1_public_shares = commitment_witness1.augmented_public_shares.clone();

        let mut party0_modified_shares = party0_public_shares.clone();
        let mut party1_modified_shares = party1_public_shares.clone();

        settle_match_into_wallets(
            &mut party0_modified_shares,
            &mut party1_modified_shares,
            party0_fees,
            party1_fees,
            party0_indices,
            party1_indices,
            &self.match_result,
        );

        // Compute the maximum amount that can be settled for each party
        let amount0: Scalar = compute_max_amount(&price, &order0, &balance0).into();
        let amount1: Scalar = compute_max_amount(&price, &order1, &balance1).into();

        // Build a witness and statement
        let witness = SizedValidMatchSettleWitness {
            order0,
            balance0,
            balance_receive0,
            amount0,
            relayer_fee0,
            party0_fees,
            price0: price,
            party0_public_shares,

            order1,
            balance1,
            balance_receive1,
            amount1,
            relayer_fee1,
            party1_fees,
            price1: price,
            party1_public_shares,

            match_res: self.match_result.clone(),
        };

        let statement = SizedValidMatchSettleStatement {
            party0_indices,
            party0_modified_shares,
            party1_indices,
            party1_modified_shares,
            protocol_fee: get_protocol_fee(),
        };

        (witness, statement)
    }

    /// Create link proofs of `VALID MATCH SETTLE` to the parties' proofs of
    /// `VALID COMMITMENTS`
    fn create_link_proofs(
        &self,
        match_settle_proof: ProofBundle,
    ) -> Result<MatchBundle, SettleMatchInternalTaskError> {
        let match_link_hint = &match_settle_proof.link_hint;
        let match_proof: ValidMatchSettleBundle = match_settle_proof.proof.into();

        let party0_comms_hint = &self.order1_validity_witness.commitment_linking_hint;
        let commitments_link0 =
            link_sized_commitments_match_settle(PARTY0, party0_comms_hint, match_link_hint)
                .map_err(|e| SettleMatchInternalTaskError::ProvingValidity(e.to_string()))?;

        let party1_comms_hint = &self.order2_validity_witness.commitment_linking_hint;
        let commitments_link1 =
            link_sized_commitments_match_settle(PARTY1, party1_comms_hint, match_link_hint)
                .map_err(|e| SettleMatchInternalTaskError::ProvingValidity(e.to_string()))?;

        Ok(MatchBundle { match_proof, commitments_link0, commitments_link1 })
    }

    /// Find and update the merkle opening for the wallet
    fn find_opening(&self, wallet: &mut Wallet) -> Result<(), SettleMatchInternalTaskError> {
        let tx = self.tx.as_ref().unwrap();
        let opening = find_merkle_path_with_tx(wallet, &self.darkpool_client, tx)?;
        wallet.merkle_proof = Some(opening);
        Ok(())
    }

    /// Spawns a task to update the validity proofs for the given wallet
    /// Returns a `JoinHandle` to the spawned task
    fn spawn_update_proofs_task(
        wallet: Wallet,
        proof_queue: ProofManagerQueue,
        state: State,
        network_sender: NetworkManagerQueue,
    ) -> TokioJoinHandle<Result<(), String>> {
        tokio::spawn(
            async move {
                update_wallet_validity_proofs(&wallet, proof_queue, state, network_sender).await
            }
            .in_current_span(),
        )
    }

    /// Emit a pair of fill events to the event manager
    fn emit_events(&self) -> Result<(), SettleMatchInternalTaskError> {
        let commitment_witness0 = &self.order1_validity_witness.commitment_witness;
        let commitment_witness1 = &self.order2_validity_witness.commitment_witness;

        let order_side0 = commitment_witness0.order.side;
        let order_side1 = commitment_witness1.order.side;

        let relayer_fee0 = commitment_witness0.relayer_fee;
        let relayer_fee1 = commitment_witness1.relayer_fee;

        let fee_take0 = compute_fee_obligation(relayer_fee0, order_side0, &self.match_result);
        let fee_take1 = compute_fee_obligation(relayer_fee1, order_side1, &self.match_result);

        let price: TimestampedPrice = self.execution_price.into();
        let fill_event0 = RelayerEventType::Fill(FillEvent::new(
            self.wallet_id1,
            self.order_id1,
            price,
            self.match_result.clone(),
            fee_take0,
        ));
        let fill_event1 = RelayerEventType::Fill(FillEvent::new(
            self.wallet_id2,
            self.order_id2,
            price,
            self.match_result.clone(),
            fee_take1,
        ));

        try_send_event(fill_event0, &self.event_queue)
            .map_err(err_str!(SettleMatchInternalTaskError::SendEvent))?;
        try_send_event(fill_event1, &self.event_queue)
            .map_err(err_str!(SettleMatchInternalTaskError::SendEvent))
    }
}
