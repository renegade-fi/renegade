//! A task to settle a match that was generated by an external matching engine

use std::error::Error;
use std::fmt::{Display, Formatter, Result as FmtResult};

use crate::task_state::StateWrapper;
use crate::traits::{Task, TaskContext, TaskError, TaskState};
use arbitrum_client::client::ArbitrumClient;
use async_trait::async_trait;
use circuit_types::r#match::MatchResult;
use common::types::proof_bundles::OrderValidityProofBundle;
use common::types::tasks::SettleExternalMatchTaskDescriptor;
use common::types::wallet::WalletIdentifier;
use common::types::TimestampedPrice;
use job_types::network_manager::NetworkManagerQueue;
use job_types::proof_manager::ProofManagerQueue;
use serde::Serialize;
use state::State;
use tracing::instrument;

// -------------
// | Constants |
// -------------

/// The name of the task
pub const SETTLE_MATCH_EXTERNAL_TASK_NAME: &str = "settle-match-external";

// --------------
// | Task State |
// --------------

/// The state of the settle match external task
#[derive(Clone, Debug, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum SettleMatchExternalTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is performing a dummy step
    ProvingAtomicMatchSettle,
    /// Await the result of the atomic match settlement to be submitted on-chain
    AwaitingSettlement,
    /// Refresh the wallet after the match settlement is witnessed on-chain
    RefreshingWallet,
    /// The task has finished
    Completed,
}

impl TaskState for SettleMatchExternalTaskState {
    fn commit_point() -> Self {
        Self::AwaitingSettlement
    }

    fn completed(&self) -> bool {
        matches!(self, Self::Completed)
    }
}

impl From<SettleMatchExternalTaskState> for StateWrapper {
    fn from(value: SettleMatchExternalTaskState) -> Self {
        Self::SettleMatchExternal(value)
    }
}

impl Display for SettleMatchExternalTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Pending => write!(f, "Pending"),
            Self::ProvingAtomicMatchSettle => write!(f, "Proving Atomic Match Settle"),
            Self::AwaitingSettlement => write!(f, "Awaiting Settlement"),
            Self::RefreshingWallet => write!(f, "Refreshing Wallet"),
            Self::Completed => write!(f, "Completed"),
        }
    }
}

// ---------------
// | Task Errors |
// ---------------

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchExternalTaskError {
    /// A dummy error
    Arbitrum(String),
}

impl TaskError for SettleMatchExternalTaskError {
    fn retryable(&self) -> bool {
        matches!(self, Self::Arbitrum(_))
    }
}

impl Display for SettleMatchExternalTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}
impl Error for SettleMatchExternalTaskError {}

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match external task
pub struct SettleMatchExternalTask {
    /// The ID of the wallet that the local node matched an order from
    internal_wallet_id: WalletIdentifier,
    /// The price at which the match was executed
    execution_price: TimestampedPrice,
    /// The match result from the external matching engine
    match_res: MatchResult,
    /// The validity proofs submitted by the local party
    internal_order_validity_bundle: OrderValidityProofBundle,
    /// The arbitrum client to use for submitting transactions
    arbitrum_client: ArbitrumClient,
    /// A sender to the network manager's work queue
    network_sender: NetworkManagerQueue,
    /// A copy of the relayer-global state
    state: State,
    /// The work queue to add proof management jobs to
    proof_queue: ProofManagerQueue,
    /// The state of the task
    task_state: SettleMatchExternalTaskState,
}

#[async_trait]
impl Task for SettleMatchExternalTask {
    type State = SettleMatchExternalTaskState;
    type Error = SettleMatchExternalTaskError;
    type Descriptor = SettleExternalMatchTaskDescriptor;

    async fn new(descriptor: Self::Descriptor, ctx: TaskContext) -> Result<Self, Self::Error> {
        let SettleExternalMatchTaskDescriptor {
            internal_wallet_id,
            execution_price,
            match_res,
            internal_order_validity_bundle,
        } = descriptor;

        Ok(Self {
            internal_wallet_id,
            execution_price,
            match_res,
            internal_order_validity_bundle,
            arbitrum_client: ctx.arbitrum_client,
            network_sender: ctx.network_queue,
            state: ctx.state,
            proof_queue: ctx.proof_queue,
            task_state: SettleMatchExternalTaskState::Pending,
        })
    }

    #[allow(clippy::blocks_in_conditions)]
    #[instrument(skip_all, err, fields(
        task = self.name(),
        state = %self.state(),
        internal_wallet_id = %self.internal_wallet_id,
    ))]
    async fn step(&mut self) -> Result<(), Self::Error> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMatchExternalTaskState::Pending => {
                self.task_state = SettleMatchExternalTaskState::ProvingAtomicMatchSettle
            },

            SettleMatchExternalTaskState::ProvingAtomicMatchSettle => {
                self.prove_atomic_match_settle().await?;
                self.task_state = SettleMatchExternalTaskState::AwaitingSettlement
            },

            SettleMatchExternalTaskState::AwaitingSettlement => {
                if self.await_settlement().await? {
                    self.task_state = SettleMatchExternalTaskState::RefreshingWallet
                } else {
                    // If settlement times out, assume that the match was not settled, and complete
                    // the task
                    self.task_state = SettleMatchExternalTaskState::Completed
                }
            },

            SettleMatchExternalTaskState::RefreshingWallet => {
                self.refresh_wallet().await?;
                self.task_state = SettleMatchExternalTaskState::Completed
            },

            SettleMatchExternalTaskState::Completed => {
                panic!("step called on completed task")
            },
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_EXTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMatchExternalTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone()
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMatchExternalTask {
    // --------------
    // | Task Steps |
    // --------------

    /// Prove the atomic match settlement
    async fn prove_atomic_match_settle(&mut self) -> Result<(), SettleMatchExternalTaskError> {
        todo!()
    }

    /// Await the result of the atomic match settlement to be submitted on-chain
    ///
    /// Returns `true` if the settlement landed on-chain, `false` otherwise
    async fn await_settlement(&mut self) -> Result<bool, SettleMatchExternalTaskError> {
        todo!()
    }

    /// Refresh the wallet after the match settlement is witnessed on-chain
    async fn refresh_wallet(&mut self) -> Result<(), SettleMatchExternalTaskError> {
        todo!()
    }

    // -----------
    // | Helpers |
    // -----------

    // Add helper methods here as needed
}
