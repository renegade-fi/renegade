//! A task to settle a match that was generated by an external matching engine

use std::error::Error;
use std::fmt::{Display, Formatter, Result as FmtResult};
use std::time::Duration;

use crate::task_state::StateWrapper;
use crate::tasks::ERR_AWAITING_PROOF;
use crate::traits::{Task, TaskContext, TaskError, TaskState};
use crate::utils::order_states::record_order_fill;
use crate::utils::validity_proofs::enqueue_proof_job;
use arbitrum_client::client::ArbitrumClient;
use arbitrum_client::constants::{
    PROCESS_ATOMIC_MATCH_SETTLE_SELECTOR, PROCESS_ATOMIC_MATCH_SETTLE_WITH_RECEIVER_SELECTOR,
};
use arbitrum_client::errors::ArbitrumClientError;
use async_trait::async_trait;
use circuit_types::fixed_point::FixedPoint;
use circuit_types::r#match::MatchResult;
use circuits::zk_circuits::proof_linking::link_sized_commitments_match_settle_atomic;
use circuits::zk_circuits::valid_match_settle_atomic::{
    SizedValidMatchSettleAtomicStatement, SizedValidMatchSettleAtomicWitness,
};
use common::types::proof_bundles::{
    AtomicMatchSettleBundle, OrderValidityProofBundle, OrderValidityWitnessBundle, ProofBundle,
    ValidMatchSettleAtomicBundle,
};
use common::types::tasks::SettleExternalMatchTaskDescriptor;
use common::types::wallet::{OrderIdentifier, WalletIdentifier};
use common::types::TimestampedPrice;
use constants::EXTERNAL_MATCH_RELAYER_FEE;
use external_api::bus_message::SystemBusMessage;
use job_types::event_manager::{
    try_send_event, EventManagerQueue, ExternalFillEvent, RelayerEvent,
};
use job_types::proof_manager::{ProofJob, ProofManagerQueue};
use serde::Serialize;
use state::error::StateError;
use state::State;
use system_bus::SystemBus;
use tracing::{info, instrument, warn};
use util::arbitrum::get_external_match_fee;
use util::matching_engine::{
    apply_match_to_shares, compute_fee_obligation, compute_fee_obligation_with_protocol_fee,
};

use super::ERR_NO_VALIDITY_PROOF;

// -------------
// | Constants |
// -------------

/// The error message emitted when an order is not found in the relayer state
pub const ERR_ORDER_NOT_FOUND: &str = "order not found";
/// The error message emitted to indicate that atomic matches are disabled
pub const ERR_ATOMIC_MATCHES_DISABLED: &str = "atomic matches are disabled";

/// The name of the task
pub const SETTLE_MATCH_EXTERNAL_TASK_NAME: &str = "settle-match-external";

/// The duration for which to wait for settlement on-chain for the purpose of
/// metrics reporting
const SETTLEMENT_METRICS_WAIT_TIME: Duration = Duration::from_secs(30);

// --------------
// | Task State |
// --------------

/// The state of the settle match external task
#[derive(Clone, Debug, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum SettleMatchExternalTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is performing a dummy step
    ProvingAtomicMatchSettle,
    /// The task is forwarding the settlement bundle to the client
    ForwardingAtomicMatchBundle,
    /// Await the result of the atomic match settlement to be submitted on-chain
    AwaitingSettlement,
    /// Refresh the wallet after the match settlement is witnessed on-chain
    RefreshingWallet,
    /// The task has finished
    Completed,
}

impl TaskState for SettleMatchExternalTaskState {
    fn commit_point() -> Self {
        Self::AwaitingSettlement
    }

    fn completed(&self) -> bool {
        matches!(self, Self::Completed)
    }
}

impl From<SettleMatchExternalTaskState> for StateWrapper {
    fn from(value: SettleMatchExternalTaskState) -> Self {
        Self::SettleMatchExternal(value)
    }
}

impl Display for SettleMatchExternalTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Pending => write!(f, "Pending"),
            Self::ProvingAtomicMatchSettle => write!(f, "Proving Atomic Match Settle"),
            Self::ForwardingAtomicMatchBundle => write!(f, "Forwarding Atomic Match Bundle"),
            Self::AwaitingSettlement => write!(f, "Awaiting Settlement"),
            Self::RefreshingWallet => write!(f, "Refreshing Wallet"),
            Self::Completed => write!(f, "Completed"),
        }
    }
}

// ---------------
// | Task Errors |
// ---------------

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchExternalTaskError {
    /// A dummy error
    Arbitrum(String),
    /// An error awaiting settlement on-chain
    AwaitingSettlement(String),
    /// An error enqueuing a job to the proof manager
    EnqueuingJob(String),
    /// An error creating a proof-link between the atomic match settle proof and
    /// the internal party's proof of `VALID COMMITMENTS`
    ProofLinking(String),
    /// An error interacting with the relayer state
    State(String),
    /// An error sending an event to the event manager
    SendEvent(String),
}

impl SettleMatchExternalTaskError {
    /// Construct an `Arbitrum` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn arbitrum<T: ToString>(msg: T) -> Self {
        Self::Arbitrum(msg.to_string())
    }

    /// Construct an `AwaitingSettlement` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn awaiting_settlement<T: ToString>(msg: T) -> Self {
        Self::AwaitingSettlement(msg.to_string())
    }

    /// Construct an `EnqueuingJob` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn enqueuing_job<T: ToString>(msg: T) -> Self {
        Self::EnqueuingJob(msg.to_string())
    }

    /// Construct a `ProofLinking` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn proof_linking<T: ToString>(msg: T) -> Self {
        Self::ProofLinking(msg.to_string())
    }

    /// Construct a `State` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn state<T: ToString>(msg: T) -> Self {
        Self::State(msg.to_string())
    }

    /// Construct a `SendEvent` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn send_event<T: ToString>(msg: T) -> Self {
        Self::SendEvent(msg.to_string())
    }
}

impl TaskError for SettleMatchExternalTaskError {
    fn retryable(&self) -> bool {
        matches!(self, Self::Arbitrum(_))
    }
}

impl Display for SettleMatchExternalTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}
impl Error for SettleMatchExternalTaskError {}

impl From<StateError> for SettleMatchExternalTaskError {
    fn from(value: StateError) -> Self {
        Self::state(value.to_string())
    }
}

impl From<ArbitrumClientError> for SettleMatchExternalTaskError {
    fn from(value: ArbitrumClientError) -> Self {
        Self::arbitrum(value.to_string())
    }
}

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match external task
#[derive(Clone)]
pub struct SettleMatchExternalTask {
    /// The ID of the order to settle
    internal_order_id: OrderIdentifier,
    /// The ID of the wallet that the local node matched an order from
    internal_wallet_id: WalletIdentifier,
    /// The price at which the match was executed
    execution_price: TimestampedPrice,
    /// The match result from the external matching engine
    match_res: MatchResult,
    /// The duration for which the external match bundle is valid
    bundle_duration: Duration,
    /// The validity proofs for the internal order
    internal_order_validity_bundle: OrderValidityProofBundle,
    /// The validity witness for an internal order
    internal_order_validity_witness: OrderValidityWitnessBundle,
    /// The atomic match settle bundle
    atomic_match_bundle: Option<AtomicMatchSettleBundle>,
    /// The system bus topic on which to send the atomic match settle bundle
    atomic_match_bundle_topic: String,
    /// The arbitrum client to use for submitting transactions
    arbitrum_client: ArbitrumClient,
    /// A copy of the relayer-global state
    state: State,
    /// A handle on the system bus
    bus: SystemBus<SystemBusMessage>,
    /// The work queue to add proof management jobs to
    proof_queue: ProofManagerQueue,
    /// The state of the task
    task_state: SettleMatchExternalTaskState,
    /// The event queue to send events to
    event_queue: EventManagerQueue,
}

#[async_trait]
impl Task for SettleMatchExternalTask {
    type State = SettleMatchExternalTaskState;
    type Error = SettleMatchExternalTaskError;
    type Descriptor = SettleExternalMatchTaskDescriptor;

    async fn new(descriptor: Self::Descriptor, ctx: TaskContext) -> Result<Self, Self::Error> {
        // Check that atomic matches are enabled
        let enabled = ctx.state.get_atomic_matches_enabled().await?;
        if !enabled {
            return Err(SettleMatchExternalTaskError::state(ERR_ATOMIC_MATCHES_DISABLED));
        }

        let SettleExternalMatchTaskDescriptor {
            bundle_duration,
            internal_order_id,
            internal_wallet_id,
            execution_price,
            match_res,
            atomic_match_bundle_topic,
        } = descriptor;
        let (internal_order_validity_bundle, internal_order_validity_witness) =
            Self::fetch_internal_order_validity_bundle(internal_order_id, &ctx.state).await?;

        Ok(Self {
            internal_order_id,
            internal_wallet_id,
            execution_price,
            match_res,
            bundle_duration,
            internal_order_validity_bundle,
            internal_order_validity_witness,
            atomic_match_bundle: None,
            atomic_match_bundle_topic,
            arbitrum_client: ctx.arbitrum_client,
            state: ctx.state,
            proof_queue: ctx.proof_queue,
            bus: ctx.bus,
            task_state: SettleMatchExternalTaskState::Pending,
            event_queue: ctx.event_queue,
        })
    }

    #[allow(clippy::blocks_in_conditions)]
    #[instrument(skip_all, err, fields(
        task = self.name(),
        state = %self.state(),
        internal_wallet_id = %self.internal_wallet_id,
    ))]
    async fn step(&mut self) -> Result<(), Self::Error> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMatchExternalTaskState::Pending => {
                self.task_state = SettleMatchExternalTaskState::ProvingAtomicMatchSettle
            },

            SettleMatchExternalTaskState::ProvingAtomicMatchSettle => {
                self.prove_atomic_match_settle().await?;
                self.task_state = SettleMatchExternalTaskState::ForwardingAtomicMatchBundle
            },

            SettleMatchExternalTaskState::ForwardingAtomicMatchBundle => {
                self.forward_atomic_match_bundle()?;
                self.task_state = SettleMatchExternalTaskState::AwaitingSettlement
            },

            SettleMatchExternalTaskState::AwaitingSettlement => {
                if self.await_settlement().await? {
                    self.task_state = SettleMatchExternalTaskState::RefreshingWallet
                } else {
                    // If settlement times out, assume that the match was not settled, and complete
                    // the task
                    self.task_state = SettleMatchExternalTaskState::Completed
                }
            },

            SettleMatchExternalTaskState::RefreshingWallet => {
                self.refresh_wallet().await?;
                self.emit_event()?;
                self.task_state = SettleMatchExternalTaskState::Completed
            },

            SettleMatchExternalTaskState::Completed => {
                panic!("step called on completed task")
            },
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_EXTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMatchExternalTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone()
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMatchExternalTask {
    // --------------
    // | Task Steps |
    // --------------

    /// Prove the atomic match settlement
    async fn prove_atomic_match_settle(&mut self) -> Result<(), SettleMatchExternalTaskError> {
        let (statement, witness) = self.get_witness_statement().await?;

        // Enqueue a job with the proof generation module
        let job = ProofJob::ValidMatchSettleAtomic { witness, statement };
        let proof_recv = enqueue_proof_job(job, &self.proof_queue)
            .map_err(SettleMatchExternalTaskError::EnqueuingJob)?;

        // Await the proof from the proof manager
        let proof = proof_recv
            .await
            .map_err(|_| SettleMatchExternalTaskError::enqueuing_job(ERR_AWAITING_PROOF))?;

        // Create proof-links between the atomic match settle proof and the internal
        // party's proof of `VALID COMMITMENTS`
        let atomic_match_bundle = self.create_link_proofs(proof)?;
        self.atomic_match_bundle = Some(atomic_match_bundle);
        Ok(())
    }

    /// Forward the atomic match settle bundle to the system bus
    fn forward_atomic_match_bundle(&self) -> Result<(), SettleMatchExternalTaskError> {
        // Build the atomic settlement bundle
        let match_bundle = self.atomic_match_bundle.clone().unwrap();
        let validity_proofs = self.internal_order_validity_bundle.clone();
        let message = SystemBusMessage::AtomicMatchFound { match_bundle, validity_proofs };
        self.bus.publish(self.atomic_match_bundle_topic.clone(), message);

        Ok(())
    }

    /// Await the result of the atomic match settlement to be submitted on-chain
    ///
    /// Returns `true` if the settlement succeeded on-chain, `false` otherwise
    async fn await_settlement(&self) -> Result<bool, SettleMatchExternalTaskError> {
        // We spawn the settlement waiter in a separate thread, to allow the task to
        // continue before settlement is observed on-chain
        let self_clone = self.clone();
        let settlement =
            tokio::spawn(async move { self_clone.await_settlement_and_record_metrics().await });

        // Wait for the settlement task to complete or timeout after bundle_duration
        match tokio::time::timeout(self.bundle_duration, settlement).await {
            Ok(result) => result.map_err(SettleMatchExternalTaskError::awaiting_settlement)?,
            Err(_) => Ok(false), // timeout
        }
    }

    /// Refresh the wallet after the match settlement is witnessed on-chain
    ///
    /// Instead of replicating the logic of the refresh task we simply enqueue a
    /// refresh task for the wallet.
    ///
    /// The wallet should have no other tasks enqueued by virtue of it being
    /// considered for atomic matches, but if it does they will fail through
    /// and be discarded
    async fn refresh_wallet(&self) -> Result<(), SettleMatchExternalTaskError> {
        // Refresh the wallet
        let wallet_id = self.internal_wallet_id;
        let task_id = self.state.append_wallet_refresh_task(wallet_id).await?;
        info!("enqueued wallet refresh task ({task_id}) for {wallet_id}");
        Ok(())
    }

    // -----------
    // | Helpers |
    // -----------

    /// Fetch the internal order validity proof bundle
    async fn fetch_internal_order_validity_bundle(
        order_id: OrderIdentifier,
        state: &State,
    ) -> Result<(OrderValidityProofBundle, OrderValidityWitnessBundle), SettleMatchExternalTaskError>
    {
        let order = state
            .get_order(&order_id)
            .await?
            .ok_or_else(|| SettleMatchExternalTaskError::state(ERR_ORDER_NOT_FOUND))?;
        let validity_proofs = order
            .validity_proofs
            .ok_or_else(|| SettleMatchExternalTaskError::state(ERR_NO_VALIDITY_PROOF))?;
        let validity_proof_witnesses = order
            .validity_proof_witnesses
            .ok_or_else(|| SettleMatchExternalTaskError::state(ERR_NO_VALIDITY_PROOF))?;

        Ok((validity_proofs, validity_proof_witnesses))
    }

    /// Get the witness and statement for the atomic match settle proof
    async fn get_witness_statement(
        &self,
    ) -> Result<
        (SizedValidMatchSettleAtomicStatement, SizedValidMatchSettleAtomicWitness),
        SettleMatchExternalTaskError,
    > {
        let commitments_witness = &self.internal_order_validity_witness.commitment_witness;
        let commitments_statement = &self.internal_order_validity_bundle.commitment_proof.statement;

        // Copy values from the witnesses and statements of the order validity proofs
        let internal_party_order = commitments_witness.order.clone();
        let internal_party_balance = commitments_witness.balance_send.clone();
        let internal_party_receive_balance = commitments_witness.balance_receive.clone();
        let internal_party_public_shares = commitments_witness.augmented_public_shares.clone();
        let internal_party_indices = commitments_statement.indices;
        let relayer_fee = commitments_witness.relayer_fee;

        // Compute the update to the internal party's state
        let protocol_fee = get_external_match_fee(&self.match_res.base_mint);
        let internal_party_fees = compute_fee_obligation_with_protocol_fee(
            relayer_fee,
            protocol_fee,
            internal_party_order.side,
            &self.match_res,
        );
        let mut internal_party_modified_shares = internal_party_public_shares.clone();
        apply_match_to_shares(
            &mut internal_party_modified_shares,
            &internal_party_indices,
            internal_party_fees,
            &self.match_res,
            internal_party_order.side,
        );

        // Compute the fees due by the external party in the match
        let relayer_fee_address = self.state.get_external_fee_addr().await?.unwrap();
        let external_party_relayer_fee =
            FixedPoint::from_f64_round_down(EXTERNAL_MATCH_RELAYER_FEE);
        let external_party_fees = compute_fee_obligation_with_protocol_fee(
            external_party_relayer_fee,
            protocol_fee,
            internal_party_order.side.opposite(),
            &self.match_res,
        );

        let statement = SizedValidMatchSettleAtomicStatement {
            match_result: self.match_res.clone().into(),
            external_party_fees,
            internal_party_modified_shares,
            internal_party_indices,
            protocol_fee,
            relayer_fee_address,
        };
        let witness = SizedValidMatchSettleAtomicWitness {
            internal_party_order,
            internal_party_balance,
            internal_party_receive_balance,
            relayer_fee,
            internal_party_fees,
            price: self.execution_price.as_fixed_point(),
            internal_party_public_shares,
        };

        Ok((statement, witness))
    }

    /// Create link proofs between the proof of `VALID MATCH SETTLE ATOMIC` and
    /// the internal party's proof of `VALID COMMITMENTS`
    fn create_link_proofs(
        &self,
        atomic_match_proof: ProofBundle,
    ) -> Result<AtomicMatchSettleBundle, SettleMatchExternalTaskError> {
        let atomic_match_hint = &atomic_match_proof.link_hint;
        let atomic_match_proof: ValidMatchSettleAtomicBundle = atomic_match_proof.proof.into();

        let commitments_hint = &self.internal_order_validity_witness.commitment_linking_hint;
        let link_proof =
            link_sized_commitments_match_settle_atomic(commitments_hint, atomic_match_hint)
                .map_err(SettleMatchExternalTaskError::proof_linking)?;

        Ok(AtomicMatchSettleBundle { atomic_match_proof, commitments_link: link_proof })
    }

    /// Await settlement on-chain and record metrics
    async fn await_settlement_and_record_metrics(
        &self,
    ) -> Result<bool, SettleMatchExternalTaskError> {
        let valid_reblind = &self.internal_order_validity_bundle.reblind_proof.statement;
        let nullifier = valid_reblind.original_shares_nullifier;
        let selectors = [
            PROCESS_ATOMIC_MATCH_SETTLE_SELECTOR,
            PROCESS_ATOMIC_MATCH_SETTLE_WITH_RECEIVER_SELECTOR,
        ];
        let res = self
            .arbitrum_client
            .await_nullifier_spent_from_selectors(
                nullifier,
                &selectors,
                SETTLEMENT_METRICS_WAIT_TIME,
            )
            .await;

        let did_settle = res.is_ok();
        if did_settle {
            self.record_fill().await?;
        } else {
            warn!("atomic match settlement not observed on-chain");
        }

        Ok(did_settle)
    }

    /// Record a fill in the internal order's fill history and in the relayer
    /// metrics
    async fn record_fill(&self) -> Result<(), SettleMatchExternalTaskError> {
        let match_res = &self.match_res;
        let price = self.execution_price;
        record_order_fill(self.internal_order_id, match_res, price, &self.state)
            .await
            .map_err(SettleMatchExternalTaskError::State)?;

        renegade_metrics::record_match_volume(match_res, true /* is_external_match */);
        Ok(())
    }

    /// Emit an external match event to the event manager
    fn emit_event(&self) -> Result<(), SettleMatchExternalTaskError> {
        let commitments_witness = &self.internal_order_validity_witness.commitment_witness;
        let internal_party_order_side = commitments_witness.order.side;
        let relayer_fee = commitments_witness.relayer_fee;
        let internal_fee_take =
            compute_fee_obligation(relayer_fee, internal_party_order_side, &self.match_res);

        let external_match_result = self.match_res.clone().into();

        let event = RelayerEvent::ExternalFill(ExternalFillEvent::new(
            self.internal_wallet_id,
            self.internal_order_id,
            self.execution_price,
            external_match_result,
            internal_fee_take,
        ));

        try_send_event(event, &self.event_queue).map_err(SettleMatchExternalTaskError::send_event)
    }
}
