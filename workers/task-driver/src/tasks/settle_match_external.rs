//! A task to settle a match that was generated by an external matching engine

use std::error::Error;
use std::fmt::{Display, Formatter, Result as FmtResult};
use std::time::Duration;

use crate::task_state::StateWrapper;
use crate::tasks::ERR_AWAITING_PROOF;
use crate::traits::{Descriptor, Task, TaskContext, TaskError, TaskState};
use crate::utils::enqueue_proof_job;
use async_trait::async_trait;
use circuit_types::fixed_point::FixedPoint;
use circuit_types::r#match::MatchResult;
use circuits::zk_circuits::valid_match_settle_atomic::{
    SizedValidMatchSettleAtomicStatement, SizedValidMatchSettleAtomicWitness,
};
use common::types::price::TimestampedPriceFp;
use common::types::proof_bundles::{
    OrderValidityProofBundle, OrderValidityWitnessBundle, ValidMatchSettleAtomicBundle,
};
use common::types::tasks::SettleExternalMatchTaskDescriptor;
use common::types::wallet::{OrderIdentifier, WalletIdentifier};
use darkpool_client::errors::DarkpoolClientError;
use external_api::bus_message::SystemBusMessage;
use job_types::proof_manager::ProofJob;
use serde::Serialize;
use state::State;
use state::error::StateError;
use tracing::instrument;
use util::matching_engine::{apply_match_to_shares, compute_fee_obligation_with_protocol_fee};
use util::on_chain::get_external_match_fee;

use super::ERR_NO_VALIDITY_PROOF;

// -------------
// | Constants |
// -------------

/// The error message emitted when an order is not found in the relayer state
pub const ERR_ORDER_NOT_FOUND: &str = "order not found";
/// The error message emitted to indicate that atomic matches are disabled
pub const ERR_ATOMIC_MATCHES_DISABLED: &str = "atomic matches are disabled";

/// The name of the task
pub const SETTLE_MATCH_EXTERNAL_TASK_NAME: &str = "settle-match-external";

// --------------
// | Task State |
// --------------

/// The state of the settle match external task
#[derive(Clone, Debug, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum SettleMatchExternalTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is performing a dummy step
    ProvingAtomicMatchSettle,
    /// The task is forwarding the settlement bundle to the client
    ForwardingAtomicMatchBundle,
    /// Await the result of the atomic match settlement to be submitted on-chain
    AwaitingSettlement,
    /// The task has finished
    Completed,
}

impl TaskState for SettleMatchExternalTaskState {
    fn commit_point() -> Self {
        Self::AwaitingSettlement
    }

    fn completed(&self) -> bool {
        matches!(self, Self::Completed)
    }
}

impl From<SettleMatchExternalTaskState> for StateWrapper {
    fn from(value: SettleMatchExternalTaskState) -> Self {
        Self::SettleMatchExternal(value)
    }
}

impl Display for SettleMatchExternalTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Pending => write!(f, "Pending"),
            Self::ProvingAtomicMatchSettle => write!(f, "Proving Atomic Match Settle"),
            Self::ForwardingAtomicMatchBundle => write!(f, "Forwarding Atomic Match Bundle"),
            Self::AwaitingSettlement => write!(f, "Awaiting Settlement"),
            Self::Completed => write!(f, "Completed"),
        }
    }
}

// ---------------
// | Task Errors |
// ---------------

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchExternalTaskError {
    /// An error interacting with the darkpool client
    Darkpool(String),
    /// An error awaiting settlement on-chain
    AwaitingSettlement(String),
    /// An error enqueuing a job to the proof manager
    EnqueuingJob(String),
    /// An error creating a proof-link between the atomic match settle proof and
    /// the internal party's proof of `VALID COMMITMENTS`
    ProofLinking(String),
    /// An error interacting with the relayer state
    State(String),
    /// An error sending an event to the event manager
    SendEvent(String),
}

impl SettleMatchExternalTaskError {
    /// Construct an `AwaitingSettlement` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn awaiting_settlement<T: ToString>(msg: T) -> Self {
        Self::AwaitingSettlement(msg.to_string())
    }

    /// Construct a `State` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn state<T: ToString>(msg: T) -> Self {
        Self::State(msg.to_string())
    }

    /// Construct an `EnqueuingJob` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn enqueuing_job<T: ToString>(msg: T) -> Self {
        Self::EnqueuingJob(msg.to_string())
    }

    /// Construct a `ProofLinking` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn proof_linking<T: ToString>(msg: T) -> Self {
        Self::ProofLinking(msg.to_string())
    }

    /// Construct a `SendEvent` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn send_event<T: ToString>(msg: T) -> Self {
        Self::SendEvent(msg.to_string())
    }
}

impl TaskError for SettleMatchExternalTaskError {
    fn retryable(&self) -> bool {
        matches!(self, Self::Darkpool(_))
    }
}

impl Display for SettleMatchExternalTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}
impl Error for SettleMatchExternalTaskError {}

impl From<StateError> for SettleMatchExternalTaskError {
    fn from(value: StateError) -> Self {
        Self::State(value.to_string())
    }
}

impl From<DarkpoolClientError> for SettleMatchExternalTaskError {
    fn from(value: DarkpoolClientError) -> Self {
        Self::Darkpool(value.to_string())
    }
}

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match external task
#[derive(Clone)]
pub struct SettleMatchExternalTask {
    /// The ID of the wallet that the local node matched an order from
    internal_wallet_id: WalletIdentifier,
    /// The price at which the match was executed
    execution_price: TimestampedPriceFp,
    /// The fee take rate for the relayer in the match
    ///
    /// This only applies to the external party at the time of writing
    relayer_fee_rate: FixedPoint,
    /// The match result from the external matching engine
    match_res: MatchResult,
    /// The duration for which the external match bundle is valid
    bundle_duration: Duration,
    /// The validity proofs for the internal order
    internal_order_validity_bundle: OrderValidityProofBundle,
    /// The validity witness for an internal order
    internal_order_validity_witness: OrderValidityWitnessBundle,
    /// The atomic match settle bundle
    atomic_match_bundle: Option<ValidMatchSettleAtomicBundle>,
    /// The system bus topic on which to send the atomic match settle bundle
    atomic_match_bundle_topic: String,
    /// The state of the task
    task_state: SettleMatchExternalTaskState,
    /// The context of the task
    ctx: TaskContext,
}

#[async_trait]
impl Task for SettleMatchExternalTask {
    type State = SettleMatchExternalTaskState;
    type Error = SettleMatchExternalTaskError;
    type Descriptor = SettleExternalMatchTaskDescriptor;

    async fn new(descriptor: Self::Descriptor, ctx: TaskContext) -> Result<Self, Self::Error> {
        // Check that atomic matches are enabled
        let enabled = ctx.state.get_atomic_matches_enabled()?;
        if !enabled {
            return Err(SettleMatchExternalTaskError::state(ERR_ATOMIC_MATCHES_DISABLED));
        }

        let SettleExternalMatchTaskDescriptor {
            bundle_duration,
            internal_order_id,
            internal_wallet_id,
            execution_price,
            relayer_fee_rate,
            match_res,
            atomic_match_bundle_topic,
        } = descriptor;
        let (internal_order_validity_bundle, internal_order_validity_witness) =
            Self::fetch_internal_order_validity_bundle(internal_order_id, &ctx.state).await?;

        Ok(Self {
            internal_wallet_id,
            execution_price,
            relayer_fee_rate,
            match_res,
            bundle_duration,
            internal_order_validity_bundle,
            internal_order_validity_witness,
            atomic_match_bundle: None,
            atomic_match_bundle_topic,
            task_state: SettleMatchExternalTaskState::Pending,
            ctx,
        })
    }

    #[allow(clippy::blocks_in_conditions)]
    #[instrument(skip_all, err, fields(
        task = self.name(),
        state = %self.state(),
        internal_wallet_id = %self.internal_wallet_id,
    ))]
    async fn step(&mut self) -> Result<(), Self::Error> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMatchExternalTaskState::Pending => {
                self.task_state = SettleMatchExternalTaskState::ProvingAtomicMatchSettle
            },

            SettleMatchExternalTaskState::ProvingAtomicMatchSettle => {
                self.prove_atomic_match_settle().await?;
                self.task_state = SettleMatchExternalTaskState::ForwardingAtomicMatchBundle
            },

            SettleMatchExternalTaskState::ForwardingAtomicMatchBundle => {
                self.forward_atomic_match_bundle()?;
                self.task_state = SettleMatchExternalTaskState::AwaitingSettlement
            },

            SettleMatchExternalTaskState::AwaitingSettlement => {
                self.await_settlement().await?;
                self.task_state = SettleMatchExternalTaskState::Completed
            },

            SettleMatchExternalTaskState::Completed => {
                panic!("step called on completed task")
            },
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_EXTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMatchExternalTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone()
    }

    /// External matches have a high rate limit and bypass the task queue to
    /// prevent raft contention
    fn bypass_task_queue(&self) -> bool {
        true
    }
}

impl Descriptor for SettleExternalMatchTaskDescriptor {
    fn bypass_task_queue(&self) -> bool {
        true
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMatchExternalTask {
    // --------------
    // | Task Steps |
    // --------------

    /// Prove the atomic match settlement
    async fn prove_atomic_match_settle(&mut self) -> Result<(), SettleMatchExternalTaskError> {
        let (statement, witness) = self.get_witness_statement()?;

        // Enqueue a job with the proof generation module
        let commitments_link = self.internal_order_validity_witness.copy_commitment_linking_hint();
        let job = ProofJob::ValidMatchSettleAtomic { witness, statement, commitments_link };
        let proof_recv = enqueue_proof_job(job, &self.ctx)
            .map_err(SettleMatchExternalTaskError::EnqueuingJob)?;

        // Await the proof from the proof manager
        let bundle = proof_recv
            .await
            .map_err(|_| SettleMatchExternalTaskError::enqueuing_job(ERR_AWAITING_PROOF))?;

        // Create proof-links between the atomic match settle proof and the internal
        // party's proof of `VALID COMMITMENTS`
        let proof_bundle = ValidMatchSettleAtomicBundle::from(bundle);
        self.atomic_match_bundle = Some(proof_bundle);
        Ok(())
    }

    /// Forward the atomic match settle bundle to the system bus
    fn forward_atomic_match_bundle(&self) -> Result<(), SettleMatchExternalTaskError> {
        // Build the atomic settlement bundle
        let match_bundle = self.atomic_match_bundle.clone().unwrap();
        let validity_proofs = self.internal_order_validity_bundle.clone();
        let message = SystemBusMessage::AtomicMatchFound { match_bundle, validity_proofs };
        self.ctx.bus.publish(self.atomic_match_bundle_topic.clone(), message);

        Ok(())
    }

    /// Waits for the bundle duration to pass so that the client may settle the
    /// match. This is done to block the task queue for the duration the bundle
    /// is guaranteed to be valid.
    async fn await_settlement(&self) -> Result<(), SettleMatchExternalTaskError> {
        tokio::time::sleep(self.bundle_duration).await;
        Ok(())
    }

    // -----------
    // | Helpers |
    // -----------

    /// Fetch the internal order validity proof bundle
    async fn fetch_internal_order_validity_bundle(
        order_id: OrderIdentifier,
        state: &State,
    ) -> Result<(OrderValidityProofBundle, OrderValidityWitnessBundle), SettleMatchExternalTaskError>
    {
        let validity_proofs = state
            .get_validity_proofs(&order_id)
            .await?
            .ok_or_else(|| SettleMatchExternalTaskError::state(ERR_NO_VALIDITY_PROOF))?;
        let validity_proof_witnesses = state
            .get_validity_proof_witness(&order_id)
            .await?
            .ok_or_else(|| SettleMatchExternalTaskError::state(ERR_NO_VALIDITY_PROOF))?;

        Ok((validity_proofs, validity_proof_witnesses))
    }

    /// Get the witness and statement for the atomic match settle proof
    fn get_witness_statement(
        &self,
    ) -> Result<
        (SizedValidMatchSettleAtomicStatement, SizedValidMatchSettleAtomicWitness),
        SettleMatchExternalTaskError,
    > {
        let commitments_witness = &self.internal_order_validity_witness.commitment_witness;
        let commitments_statement = &self.internal_order_validity_bundle.commitment_proof.statement;

        // Copy values from the witnesses and statements of the order validity proofs
        let internal_party_order = commitments_witness.order.clone();
        let internal_party_balance = commitments_witness.balance_send.clone();
        let internal_party_receive_balance = commitments_witness.balance_receive.clone();
        let internal_party_public_shares = commitments_witness.augmented_public_shares.clone();
        let internal_party_indices = commitments_statement.indices;
        let relayer_fee = commitments_witness.relayer_fee;

        // Compute the update to the internal party's state
        let protocol_fee = get_external_match_fee(&self.match_res.base_mint);
        let internal_party_fees = compute_fee_obligation_with_protocol_fee(
            relayer_fee,
            protocol_fee,
            internal_party_order.side,
            &self.match_res,
        );
        let mut internal_party_modified_shares = internal_party_public_shares.clone();
        apply_match_to_shares(
            &mut internal_party_modified_shares,
            &internal_party_indices,
            internal_party_fees,
            &self.match_res,
            internal_party_order.side,
        );

        // Compute the fees due by the external party in the match
        let relayer_fee_address = self.ctx.state.get_external_fee_addr()?.unwrap();
        let external_party_relayer_fee = self.relayer_fee_rate;
        let external_party_fees = compute_fee_obligation_with_protocol_fee(
            external_party_relayer_fee,
            protocol_fee,
            internal_party_order.side.opposite(),
            &self.match_res,
        );

        let statement = SizedValidMatchSettleAtomicStatement {
            match_result: self.match_res.clone().into(),
            external_party_fees,
            internal_party_modified_shares,
            internal_party_indices,
            protocol_fee,
            relayer_fee_address,
        };
        let witness = SizedValidMatchSettleAtomicWitness {
            internal_party_order,
            internal_party_balance,
            internal_party_receive_balance,
            relayer_fee,
            internal_party_fees,
            price: self.execution_price.price(),
            internal_party_public_shares,
        };

        Ok((statement, witness))
    }
}
