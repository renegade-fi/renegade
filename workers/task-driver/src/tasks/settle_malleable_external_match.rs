//! A task to settle a malleable match that was generated by an external
//! matching engine
//!
//! A malleable match is one in which the base amount is not known at the time
//! the proof is generated. Therefore, the match proves valid bounds on the base
//! amount.

use std::error::Error;
use std::fmt::{Display, Formatter, Result as FmtResult};
use std::time::Duration;

use crate::task_state::StateWrapper;
use crate::tasks::ERR_AWAITING_PROOF;
use crate::traits::{Task, TaskContext, TaskError, TaskState};
use crate::utils::validity_proofs::enqueue_proof_job;
use async_trait::async_trait;
use circuit_types::fees::FeeTakeRate;
use circuit_types::fixed_point::FixedPoint;
use circuit_types::r#match::BoundedMatchResult;
use circuits::zk_circuits::proof_linking::link_sized_commitments_atomic_match_settle;
use circuits::zk_circuits::valid_malleable_match_settle_atomic::{
    SizedValidMalleableMatchSettleAtomicStatement, SizedValidMalleableMatchSettleAtomicWitness,
};
use common::types::proof_bundles::{
    MalleableAtomicMatchSettleBundle, OrderValidityProofBundle, OrderValidityWitnessBundle,
    ProofBundle, ValidMalleableMatchSettleAtomicBundle,
};
use common::types::tasks::SettleMalleableExternalMatchTaskDescriptor;
use common::types::wallet::{OrderIdentifier, WalletIdentifier};
use constants::EXTERNAL_MATCH_RELAYER_FEE;
use darkpool_client::errors::DarkpoolClientError;
use external_api::bus_message::SystemBusMessage;
use job_types::proof_manager::{ProofJob, ProofManagerQueue};
use serde::Serialize;
use state::State;
use state::error::StateError;
use system_bus::SystemBus;
use tracing::instrument;
use util::on_chain::get_external_match_fee;

use super::ERR_NO_VALIDITY_PROOF;

// -------------
// | Constants |
// -------------

/// The error message emitted when an order is not found in the relayer state
pub const ERR_ORDER_NOT_FOUND: &str = "order not found";
/// The error message emitted to indicate that atomic matches are disabled
pub const ERR_ATOMIC_MATCHES_DISABLED: &str = "atomic matches are disabled";

/// The name of the task
pub const SETTLE_MATCH_EXTERNAL_TASK_NAME: &str = "settle-match-external";

// --------------
// | Task State |
// --------------

/// The state of the settle match external task
#[derive(Clone, Debug, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum SettleMalleableExternalMatchTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is performing a dummy step
    ProvingAtomicMatchSettle,
    /// The task is forwarding the settlement bundle to the client
    ForwardingAtomicMatchBundle,
    /// Await the result of the atomic match settlement to be submitted on-chain
    AwaitingSettlement,
    /// The task has finished
    Completed,
}

impl TaskState for SettleMalleableExternalMatchTaskState {
    fn commit_point() -> Self {
        Self::AwaitingSettlement
    }

    fn completed(&self) -> bool {
        matches!(self, Self::Completed)
    }
}

impl From<SettleMalleableExternalMatchTaskState> for StateWrapper {
    fn from(value: SettleMalleableExternalMatchTaskState) -> Self {
        Self::SettleMalleableExternalMatch(value)
    }
}

impl Display for SettleMalleableExternalMatchTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Pending => write!(f, "Pending"),
            Self::ProvingAtomicMatchSettle => write!(f, "Proving Malleable Atomic Match Settle"),
            Self::ForwardingAtomicMatchBundle => write!(f, "Forwarding Atomic Match Bundle"),
            Self::AwaitingSettlement => write!(f, "Awaiting Settlement"),
            Self::Completed => write!(f, "Completed"),
        }
    }
}

// ---------------
// | Task Errors |
// ---------------

/// A type alias for a result that errors with a
/// `SettleMalleableExternalMatchTaskError`
pub type Result<T> = std::result::Result<T, SettleMalleableExternalMatchTaskError>;

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMalleableExternalMatchTaskError {
    /// An error interacting with the darkpool client
    Darkpool(String),
    /// An error awaiting settlement on-chain
    AwaitingSettlement(String),
    /// An error enqueuing a job to the proof manager
    EnqueuingJob(String),
    /// An error creating a proof-link between the atomic match settle proof and
    /// the internal party's proof of `VALID COMMITMENTS`
    ProofLinking(String),
    /// An error interacting with the relayer state
    State(String),
    /// An error sending an event to the event manager
    SendEvent(String),
}

impl SettleMalleableExternalMatchTaskError {
    /// Construct an `AwaitingSettlement` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn awaiting_settlement<T: ToString>(msg: T) -> Self {
        Self::AwaitingSettlement(msg.to_string())
    }

    /// Construct a `State` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn state<T: ToString>(msg: T) -> Self {
        Self::State(msg.to_string())
    }

    /// Construct an `EnqueuingJob` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn enqueuing_job<T: ToString>(msg: T) -> Self {
        Self::EnqueuingJob(msg.to_string())
    }

    /// Construct a `ProofLinking` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn proof_linking<T: ToString>(msg: T) -> Self {
        Self::ProofLinking(msg.to_string())
    }

    /// Construct a `SendEvent` error
    #[allow(clippy::needless_pass_by_value)]
    pub fn send_event<T: ToString>(msg: T) -> Self {
        Self::SendEvent(msg.to_string())
    }
}

impl TaskError for SettleMalleableExternalMatchTaskError {
    fn retryable(&self) -> bool {
        matches!(self, Self::Darkpool(_))
    }
}

impl Display for SettleMalleableExternalMatchTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}
impl Error for SettleMalleableExternalMatchTaskError {}

impl From<StateError> for SettleMalleableExternalMatchTaskError {
    fn from(value: StateError) -> Self {
        Self::State(value.to_string())
    }
}

impl From<DarkpoolClientError> for SettleMalleableExternalMatchTaskError {
    fn from(value: DarkpoolClientError) -> Self {
        Self::Darkpool(value.to_string())
    }
}

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match external task
#[derive(Clone)]
pub struct SettleMalleableExternalMatchTask {
    /// The ID of the wallet that the local node matched an order from
    internal_wallet_id: WalletIdentifier,
    /// The match result from the external matching engine
    match_res: BoundedMatchResult,
    /// The duration for which the external match bundle is valid
    bundle_duration: Duration,
    /// The validity proofs for the internal order
    internal_order_validity_bundle: OrderValidityProofBundle,
    /// The validity witness for an internal order
    internal_order_validity_witness: OrderValidityWitnessBundle,
    /// The atomic match settle bundle
    atomic_match_bundle: Option<MalleableAtomicMatchSettleBundle>,
    /// The system bus topic on which to send the atomic match settle bundle
    atomic_match_bundle_topic: String,
    /// A copy of the relayer-global state
    state: State,
    /// A handle on the system bus
    bus: SystemBus<SystemBusMessage>,
    /// The work queue to add proof management jobs to
    proof_queue: ProofManagerQueue,
    /// The state of the task
    task_state: SettleMalleableExternalMatchTaskState,
}

#[async_trait]
impl Task for SettleMalleableExternalMatchTask {
    type State = SettleMalleableExternalMatchTaskState;
    type Error = SettleMalleableExternalMatchTaskError;
    type Descriptor = SettleMalleableExternalMatchTaskDescriptor;

    async fn new(descriptor: Self::Descriptor, ctx: TaskContext) -> Result<Self> {
        // Check that atomic matches are enabled
        let enabled = ctx.state.get_atomic_matches_enabled().await?;
        if !enabled {
            return Err(SettleMalleableExternalMatchTaskError::state(ERR_ATOMIC_MATCHES_DISABLED));
        }

        let SettleMalleableExternalMatchTaskDescriptor {
            bundle_duration,
            internal_order_id,
            internal_wallet_id,
            match_res,
            atomic_match_bundle_topic,
        } = descriptor;
        let (internal_order_validity_bundle, internal_order_validity_witness) =
            Self::fetch_internal_order_validity_bundle(internal_order_id, &ctx.state).await?;

        Ok(Self {
            internal_wallet_id,
            match_res,
            bundle_duration,
            internal_order_validity_bundle,
            internal_order_validity_witness,
            atomic_match_bundle: None,
            atomic_match_bundle_topic,
            state: ctx.state,
            proof_queue: ctx.proof_queue,
            bus: ctx.bus,
            task_state: SettleMalleableExternalMatchTaskState::Pending,
        })
    }

    #[allow(clippy::blocks_in_conditions)]
    #[instrument(skip_all, err, fields(
        task = self.name(),
        state = %self.state(),
        internal_wallet_id = %self.internal_wallet_id,
    ))]
    async fn step(&mut self) -> Result<()> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMalleableExternalMatchTaskState::Pending => {
                self.task_state = SettleMalleableExternalMatchTaskState::ProvingAtomicMatchSettle
            },

            SettleMalleableExternalMatchTaskState::ProvingAtomicMatchSettle => {
                self.prove_atomic_match_settle().await?;
                self.task_state = SettleMalleableExternalMatchTaskState::ForwardingAtomicMatchBundle
            },

            SettleMalleableExternalMatchTaskState::ForwardingAtomicMatchBundle => {
                self.forward_atomic_match_bundle()?;
                self.task_state = SettleMalleableExternalMatchTaskState::AwaitingSettlement
            },

            SettleMalleableExternalMatchTaskState::AwaitingSettlement => {
                self.await_settlement().await?;
                self.task_state = SettleMalleableExternalMatchTaskState::Completed
            },

            SettleMalleableExternalMatchTaskState::Completed => {
                panic!("step called on completed task")
            },
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_EXTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMalleableExternalMatchTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone()
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMalleableExternalMatchTask {
    // --------------
    // | Task Steps |
    // --------------

    /// Prove the atomic match settlement
    async fn prove_atomic_match_settle(&mut self) -> Result<()> {
        let (statement, witness) = self.get_witness_statement().await?;

        // Enqueue a job with the proof generation module
        let job = ProofJob::ValidMalleableMatchSettleAtomic { witness, statement };
        let proof_recv = enqueue_proof_job(job, &self.proof_queue)
            .map_err(SettleMalleableExternalMatchTaskError::EnqueuingJob)?;

        // Await the proof from the proof manager
        let proof = proof_recv.await.map_err(|_| {
            SettleMalleableExternalMatchTaskError::enqueuing_job(ERR_AWAITING_PROOF)
        })?;

        // Create proof-links between the atomic match settle proof and the internal
        // party's proof of `VALID COMMITMENTS`
        let atomic_match_bundle = self.create_link_proofs(proof)?;
        self.atomic_match_bundle = Some(atomic_match_bundle);
        Ok(())
    }

    /// Forward the atomic match settle bundle to the system bus
    fn forward_atomic_match_bundle(&self) -> Result<()> {
        // Build the atomic settlement bundle
        let match_bundle = self.atomic_match_bundle.clone().unwrap();
        let validity_proofs = self.internal_order_validity_bundle.clone();
        let message = SystemBusMessage::MalleableAtomicMatchFound { match_bundle, validity_proofs };
        self.bus.publish(self.atomic_match_bundle_topic.clone(), message);

        Ok(())
    }

    /// Waits for the bundle duration to pass so that the client may settle the
    /// match. This is done to block the task queue for the duration the bundle
    /// is guaranteed to be valid.
    async fn await_settlement(&self) -> Result<()> {
        tokio::time::sleep(self.bundle_duration).await;
        Ok(())
    }

    // -----------
    // | Helpers |
    // -----------

    /// Fetch the internal order validity proof bundle
    async fn fetch_internal_order_validity_bundle(
        order_id: OrderIdentifier,
        state: &State,
    ) -> Result<(OrderValidityProofBundle, OrderValidityWitnessBundle)> {
        let order = state
            .get_order(&order_id)
            .await?
            .ok_or_else(|| SettleMalleableExternalMatchTaskError::state(ERR_ORDER_NOT_FOUND))?;
        let validity_proofs = order
            .validity_proofs
            .ok_or_else(|| SettleMalleableExternalMatchTaskError::state(ERR_NO_VALIDITY_PROOF))?;
        let validity_proof_witnesses = order
            .validity_proof_witnesses
            .ok_or_else(|| SettleMalleableExternalMatchTaskError::state(ERR_NO_VALIDITY_PROOF))?;

        Ok((validity_proofs, validity_proof_witnesses))
    }

    /// Get the witness and statement for the atomic match settle proof
    /// `VALID ATOMIC MATCH SETTLE` for an exact match
    async fn get_witness_statement(
        &self,
    ) -> Result<(
        SizedValidMalleableMatchSettleAtomicStatement,
        SizedValidMalleableMatchSettleAtomicWitness,
    )> {
        let match_res = &self.match_res;
        let commitments_witness = &self.internal_order_validity_witness.commitment_witness;
        let relayer_fee_address = self.state.get_external_fee_addr().await?.unwrap();

        // Copy values from the witnesses and statements of the order validity proofs
        let internal_party_order = commitments_witness.order.clone();
        let internal_party_balance = commitments_witness.balance_send.clone();
        let internal_party_receive_balance = commitments_witness.balance_receive.clone();
        let internal_party_public_shares = commitments_witness.augmented_public_shares.clone();
        let internal_party_relayer_fee = commitments_witness.relayer_fee;

        let external_party_relayer_fee =
            FixedPoint::from_f64_round_down(EXTERNAL_MATCH_RELAYER_FEE);
        let protocol_fee = get_external_match_fee(&match_res.base_mint);
        let internal_fee_rates = FeeTakeRate::new(internal_party_relayer_fee, protocol_fee);
        let external_fee_rates = FeeTakeRate::new(external_party_relayer_fee, protocol_fee);

        // Compute the fees due by the external party in the match
        let statement = SizedValidMalleableMatchSettleAtomicStatement {
            bounded_match_result: match_res.clone(),
            external_fee_rates,
            internal_fee_rates,
            internal_party_public_shares: internal_party_public_shares.clone(),
            relayer_fee_address,
        };

        let witness = SizedValidMalleableMatchSettleAtomicWitness {
            internal_party_order,
            internal_party_balance,
            internal_party_receive_balance,
            internal_party_relayer_fee,
            internal_party_public_shares,
        };

        Ok((statement, witness))
    }

    /// Create link proofs between the proof of `VALID MATCH SETTLE ATOMIC` and
    /// the internal party's proof of `VALID COMMITMENTS`
    fn create_link_proofs(
        &self,
        atomic_match_proof: ProofBundle,
    ) -> Result<MalleableAtomicMatchSettleBundle> {
        let atomic_match_hint = &atomic_match_proof.link_hint;
        let atomic_match_proof: ValidMalleableMatchSettleAtomicBundle =
            atomic_match_proof.proof.into();

        let commitments_hint = &self.internal_order_validity_witness.commitment_linking_hint;
        let link_proof =
            link_sized_commitments_atomic_match_settle(commitments_hint, atomic_match_hint)
                .map_err(SettleMalleableExternalMatchTaskError::proof_linking)?;

        Ok(MalleableAtomicMatchSettleBundle { atomic_match_proof, commitments_link: link_proof })
    }
}
