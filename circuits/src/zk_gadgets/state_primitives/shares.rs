//! Secret share gadgets

use circuit_types::{
    PlonkCircuit,
    balance::{BalanceShareVar, BalanceVar, PostMatchBalanceShareVar, PostMatchBalanceVar},
    intent::{IntentShareVar, PreMatchIntentShareVar},
    traits::{CircuitVarType, SecretShareVarType},
};
use mpc_relation::traits::Circuit;
use mpc_relation::{Variable, errors::CircuitError};

/// A gadget for operating on secret shares
pub struct ShareGadget;
impl ShareGadget {
    /// Recover a base type from a set of shares
    pub fn recover_base<S: SecretShareVarType>(
        private_share: &S,
        public_share: &S,
        cs: &mut PlonkCircuit,
    ) -> Result<S::Base, CircuitError> {
        // Serialize into vars
        let private_share_vars = private_share.to_vars();
        let public_share_vars = public_share.to_vars();

        // Recover the base type from the shares
        let base_vars = public_share_vars
            .iter()
            .zip(private_share_vars.iter())
            .map(|(p, s)| cs.add(*p, *s))
            .collect::<Result<Vec<Variable>, CircuitError>>()?;
        let base = S::Base::from_vars(&mut base_vars.into_iter(), cs);
        Ok(base)
    }

    /// Compute the complementary set of secret shares given a base type and one
    /// set of shares
    ///
    /// That is, compute those shares which sum with the given set of shares to
    /// produce the base type
    pub fn compute_complementary_shares<S: SecretShareVarType>(
        shares: &S,
        base: &S::Base,
        cs: &mut PlonkCircuit,
    ) -> Result<S, CircuitError> {
        // Serialize into vars
        let shares_vars = shares.to_vars();
        let base_vars = base.to_vars();

        // Compute the complementary set of shares and deserialize into the share type
        let complementary_shares_vars = base_vars
            .iter()
            .zip(shares_vars.iter())
            .map(|(b, s)| cs.sub(*b, *s))
            .collect::<Result<Vec<Variable>, CircuitError>>()?;
        let complementary_shares = S::from_vars(&mut complementary_shares_vars.into_iter(), cs);
        Ok(complementary_shares)
    }

    // --- Partial Shares --- //

    /// Convert an `IntentShareVar` into a `PreMatchIntentShare`
    pub fn build_pre_match_intent_share(intent_share: &IntentShareVar) -> PreMatchIntentShareVar {
        PreMatchIntentShareVar {
            in_token: intent_share.in_token,
            out_token: intent_share.out_token,
            owner: intent_share.owner,
            min_price: intent_share.min_price.clone(),
        }
    }

    /// Build a post-match balance share from a balance
    pub fn build_post_match_balance(pre_match_balance: &BalanceVar) -> PostMatchBalanceVar {
        PostMatchBalanceVar {
            amount: pre_match_balance.amount,
            relayer_fee_balance: pre_match_balance.relayer_fee_balance,
            protocol_fee_balance: pre_match_balance.protocol_fee_balance,
        }
    }

    /// Build a post-match balance share from a balance share
    pub fn build_post_match_balance_share(
        balance_share: &BalanceShareVar,
    ) -> PostMatchBalanceShareVar {
        PostMatchBalanceShareVar {
            amount: balance_share.amount,
            relayer_fee_balance: balance_share.relayer_fee_balance,
            protocol_fee_balance: balance_share.protocol_fee_balance,
        }
    }

    /// Update a balance share with the given post-match balance
    ///
    /// Mutates the given balance share in place.
    pub fn update_balance_share_post_match(
        balance_share: &mut BalanceShareVar,
        post_match_balance: &PostMatchBalanceShareVar,
    ) {
        balance_share.amount = post_match_balance.amount;
        balance_share.relayer_fee_balance = post_match_balance.relayer_fee_balance;
        balance_share.protocol_fee_balance = post_match_balance.protocol_fee_balance;
    }
}

#[cfg(test)]
mod test {
    use constants::Scalar;
    use eyre::Result;
    use itertools::Itertools;
    use rand::{distributions::uniform::SampleRange, thread_rng};

    use crate::{
        test_helpers::random_scalars_array, zk_gadgets::primitives::comparators::EqGadget,
    };

    use super::*;
    use circuit_types::traits::CircuitBaseType;

    /// Test that the complementary shares generated by the gadget sum to the
    /// base
    #[test]
    fn test_recover_base() -> Result<()> {
        // Generate test data
        const N: usize = 100;
        let share1: [Scalar; N] = random_scalars_array();
        let share2: [Scalar; N] = random_scalars_array();
        let base: [Scalar; N] = share1
            .iter()
            .zip(share2.iter())
            .map(|(s1, s2)| *s1 + *s2)
            .collect_vec()
            .try_into()
            .unwrap();

        // Check that the sampled shares recover the base
        let mut cs = PlonkCircuit::new_turbo_plonk();
        let share1_var = share1.create_witness(&mut cs);
        let share2_var = share2.create_witness(&mut cs);
        let base_var = base.create_witness(&mut cs);
        let recovered_shares_var = ShareGadget::recover_base(&share1_var, &share2_var, &mut cs)?;
        EqGadget::constrain_eq(&recovered_shares_var, &base_var, &mut cs)?;

        // Check satisfiability
        assert!(cs.check_circuit_satisfiability(&[]).is_ok());
        Ok(())
    }

    /// Test that the recovery gadget and the complementary shares gadget are
    /// consistent
    #[test]
    fn test_recover_base_and_compute_complementary_shares() -> Result<()> {
        // Generate test data
        const N: usize = 100;
        let share1: [Scalar; N] = random_scalars_array();
        let share2: [Scalar; N] = random_scalars_array();
        let base: [Scalar; N] = share1
            .iter()
            .zip(share2.iter())
            .map(|(s1, s2)| *s1 + *s2)
            .collect_vec()
            .try_into()
            .unwrap();

        // Allocate in a constraint system
        let mut cs = PlonkCircuit::new_turbo_plonk();
        let share1_var = share1.create_witness(&mut cs);
        let share2_var = share2.create_witness(&mut cs);
        let base_var = base.create_witness(&mut cs);

        // 1. Get the shares which are complementary to `share1`
        let complementary_shares1 =
            ShareGadget::compute_complementary_shares(&share1_var, &base_var, &mut cs)?;
        EqGadget::constrain_eq(&complementary_shares1, &share2_var, &mut cs)?;

        // 2. Recover the base from the shares
        let recovered_base =
            ShareGadget::recover_base(&complementary_shares1, &share1_var, &mut cs)?;
        EqGadget::constrain_eq(&recovered_base, &base_var, &mut cs)?;

        // Check satisfiability
        assert!(cs.check_circuit_satisfiability(&[]).is_ok());
        Ok(())
    }

    /// Test the complementary shares gadget
    #[test]
    fn test_compute_complementary_shares() -> Result<()> {
        // Generate test data
        const N: usize = 100;
        let share1: [Scalar; N] = random_scalars_array();
        let share2: [Scalar; N] = random_scalars_array();
        let base: [Scalar; N] = share1
            .iter()
            .zip(share2.iter())
            .map(|(s1, s2)| *s1 + *s2)
            .collect_vec()
            .try_into()
            .unwrap();

        // Allocate in a constraint system
        let mut cs = PlonkCircuit::new_turbo_plonk();
        let share1_var = share1.create_witness(&mut cs);
        let share2_var = share2.create_witness(&mut cs);
        let base_var = base.create_witness(&mut cs);

        // Compute the complementary shares and enforce that they're equal to the other
        // shares
        let complementary_shares =
            ShareGadget::compute_complementary_shares(&share1_var, &base_var, &mut cs)?;
        EqGadget::constrain_eq(&complementary_shares, &share2_var, &mut cs)?;

        // Check satisfiability
        assert!(cs.check_circuit_satisfiability(&[]).is_ok());
        Ok(())
    }

    /// Test the complementary shares gadget with invalid shares
    #[test]
    #[allow(non_snake_case)]
    fn test_compute_complementary_shares__invalid() -> Result<()> {
        let mut rng = thread_rng();

        // Generate test data
        const N: usize = 100;
        let mut share1: [Scalar; N] = random_scalars_array();
        let share2: [Scalar; N] = random_scalars_array();
        let base: [Scalar; N] = share1
            .iter()
            .zip(share2.iter())
            .map(|(s1, s2)| *s1 + *s2)
            .collect_vec()
            .try_into()
            .unwrap();

        // Corrupt one share
        let idx = (0..N).sample_single(&mut rng);
        share1[idx] = Scalar::random(&mut rng);

        // Allocate in a constraint system
        let mut cs = PlonkCircuit::new_turbo_plonk();
        let share1_var = share1.create_witness(&mut cs);
        let share2_var = share2.create_witness(&mut cs);
        let base_var = base.create_witness(&mut cs);

        // Compute the complementary shares and enforce that they're equal to the other
        // shares
        let complementary_shares =
            ShareGadget::compute_complementary_shares(&share1_var, &base_var, &mut cs)?;
        EqGadget::constrain_eq(&complementary_shares, &share2_var, &mut cs)?;

        // Check satisfiability
        assert!(cs.check_circuit_satisfiability(&[]).is_err());
        Ok(())
    }
}
