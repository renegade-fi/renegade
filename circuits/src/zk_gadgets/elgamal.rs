//! A thin wrapper around the `jf-primitives` ElGamal gadgets
//!
//! We perform EC-ElGamal over the BabyJubJub curve, which has a base field the
//! same size as the BN254 scalar field
#![allow(missing_docs)]

use ark_ec::AffineRepr;
use circuit_macros::circuit_type;
use circuit_types::keychain::{
    BabyJubJubPoint, BabyJubJubPointVar, DecryptionKeyVar, EncryptionKeyVar,
};
use circuit_types::{
    traits::{BaseType, CircuitBaseType, CircuitVarType},
    PlonkCircuit,
};
use constants::{EmbeddedCurveConfig, ScalarField};
use constants::{EmbeddedCurveGroupAffine, Scalar};
use jf_primitives::circuit::elgamal::{ElGamalEncryptionGadget, ElGamalHybridCtxtVars, EncKeyVars};
use mpc_relation::{errors::CircuitError, traits::Circuit, Variable};

use super::comparators::EqGadget;

// ---------
// | Types |
// ---------

/// A ciphertext in the EC-ElGamal cryptosystem
///
/// We use a hybrid encryption scheme in which the plaintext is encrypted under
/// a pad generated by a stream cipher. The stream is seeded by the coordinates
/// of the ephemeral key
#[circuit_type(serde, singleprover_circuit)]
#[derive(Clone, Debug)]
pub struct ElGamalCiphertext<const N: usize> {
    /// The ephemeral key
    pub ephemeral_key: BabyJubJubPoint,
    /// The ciphertext
    pub ciphertext: [Scalar; N],
}

/// Conversion from `jf-primitives` types
impl<const N: usize> From<ElGamalHybridCtxtVars> for ElGamalCiphertextVar<N> {
    fn from(value: ElGamalHybridCtxtVars) -> Self {
        let ephemeral_key = value.ephemeral.into();
        let ciphertext = value.symm_ctxts.try_into().expect("Invalid ciphertext size");

        Self { ephemeral_key, ciphertext }
    }
}

// -----------
// | Gadgets |
// -----------

/// A gadget for verifying operations in the EC-ElGamal cryptosystem over the
/// BabyJubJub curve
pub struct ElGamalGadget;

impl ElGamalGadget {
    /// Verify that a given decryption key has the given associated encryption
    /// key
    ///
    /// This can be done as a form of authorization, or PoK of decryption key
    /// without actually decrypting a ciphertext.
    ///
    /// Formally this is `k * G == P` where `k` is the decryption key, `G` is
    /// the generator of the curve, and `P` is the encryption key
    #[allow(non_snake_case)]
    pub fn verify_decryption_key(
        decryption_key: &DecryptionKeyVar,
        encryption_key: &EncryptionKeyVar,
        cs: &mut PlonkCircuit,
    ) -> Result<(), CircuitError> {
        // k * G
        let gen = EmbeddedCurveGroupAffine::generator();
        let kG = cs.fixed_base_scalar_mul(decryption_key.key, &gen)?;
        let kG_point = BabyJubJubPointVar::from(kG);

        EqGadget::constrain_eq(&kG_point, encryption_key, cs)
    }

    /// Encrypt a given plaintext under the key and check that it matches the
    /// given encryption
    pub fn check_ciphertext<const N: usize>(
        plaintext: &[Variable; N],
        key: &EncryptionKeyVar,
        randomness: Variable,
        expected_ciphertext: &ElGamalCiphertextVar<N>,
        cs: &mut PlonkCircuit,
    ) -> Result<(), CircuitError> {
        let pk_var = EncKeyVars(key.clone().into());
        let ciphertext =
            <PlonkCircuit as ElGamalEncryptionGadget<_, EmbeddedCurveConfig>>::elgamal_encrypt(
                cs, &pk_var, plaintext, randomness,
            )?;

        let ciphertext_var = ElGamalCiphertextVar::<N>::from(ciphertext);
        EqGadget::constrain_eq(&ciphertext_var, expected_ciphertext, cs)
    }
}

#[cfg(any(test, feature = "test_helpers"))]
pub mod test_helpers {
    //! Test helpers for the ElGamal gadgets

    use circuit_types::keychain::{DecryptionKey, EncryptionKey};
    use jf_primitives::elgamal::KeyPair;
    use rand::thread_rng;

    /// Create a random keypair
    pub fn random_elgamal_keypair() -> (EncryptionKey, DecryptionKey) {
        let mut rng = thread_rng();
        let keypair = KeyPair::generate(&mut rng);

        let enc = keypair.enc_key().into();
        let dec = keypair.dec_key().into();

        (enc, dec)
    }
}

#[cfg(test)]
mod test {
    use ark_ff::UniformRand;
    use circuit_types::{keychain::DecryptionKey, traits::CircuitBaseType, PlonkCircuit};
    use constants::EmbeddedScalarField;
    use mpc_relation::traits::Circuit;
    use rand::thread_rng;

    use super::{test_helpers::random_elgamal_keypair, ElGamalGadget};

    /// Tests the `verify_decryption_key` method
    #[test]
    fn test_verify_decryption_key() {
        let mut rng = thread_rng();

        // Correct keypair
        let (enc, dec) = random_elgamal_keypair();

        let mut cs = PlonkCircuit::new_turbo_plonk();
        let enc_var = enc.create_witness(&mut cs);
        let dec_var = dec.create_witness(&mut cs);

        ElGamalGadget::verify_decryption_key(&dec_var, &enc_var, &mut cs).unwrap();
        assert!(cs.check_circuit_satisfiability(&[]).is_ok());

        // Incorrect keypair
        let (enc, _) = random_elgamal_keypair();
        let dec = DecryptionKey { key: EmbeddedScalarField::rand(&mut rng) };

        let mut cs = PlonkCircuit::new_turbo_plonk();
        let enc_var = enc.create_witness(&mut cs);
        let dec_var = dec.create_witness(&mut cs);

        ElGamalGadget::verify_decryption_key(&dec_var, &enc_var, &mut cs).unwrap();
        assert!(cs.check_circuit_satisfiability(&[]).is_err());
    }
}
