//! Groups type definitions for protocol notes: a state primitive which is created upon a transfer
//! or a successful match. Notes are redeemed into the balances of a wallet and nullified.

use crypto::fields::biguint_to_scalar;
use curve25519_dalek::{ristretto::CompressedRistretto, scalar::Scalar};
use mpc_bulletproof::r1cs::{Prover, Variable, Verifier};
use num_bigint::BigUint;
use serde::{Deserialize, Serialize};

use crate::{CommitProver, CommitVerifier};

use super::order::OrderSide;

/// Represents the various ways in which a Note may be generated
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum NoteType {
    /// A note generated by an internal transfer within the darkpool
    InternalTransfer = 0,
    /// A note generated by a match that occurred in the p2p network
    Match = 1,
}

/// Represents a note base type
#[derive(Clone, Debug)]
pub struct Note {
    /// The first mint exchanged via the note
    pub mint1: BigUint,
    /// The volume of the first mint exchanged  
    pub volume1: u64,
    /// The direction of the first mint
    pub direction1: OrderSide,
    /// The second mint exchanged via the note
    pub mint2: BigUint,
    /// The volume of the second mint exchanged
    pub volume2: u64,
    /// The direction of the second mint
    pub direction2: OrderSide,
    /// The mint of the relayer fee paid on contract interaction
    pub fee_mint: BigUint,
    /// The volume of the relayer fee paid on contract interaction
    pub fee_volume: u64,
    /// The direction of the relayer fee, will be Buy for the relayer's note
    pub fee_direction: OrderSide,
    /// The note type, indicating whether this note was generated by transfer
    /// or by match
    pub type_: NoteType,
    /// The randomness included with the note, used to authenticate notes
    pub randomness: u64,
}

/// Represents a note that has been allocated in a constraint system
#[derive(Copy, Clone, Debug)]
pub struct NoteVar {
    /// The first mint exchanged via the note
    pub mint1: Variable,
    /// The volume of the first mint exchanged  
    pub volume1: Variable,
    /// The direction of the first mint
    pub direction1: Variable,
    /// The second mint exchanged via the note
    pub mint2: Variable,
    /// The volume of the second mint exchanged
    pub volume2: Variable,
    /// The direction of the second mint
    pub direction2: Variable,
    /// The mint of the relayer fee paid on contract interaction
    pub fee_mint: Variable,
    /// The volume of the relayer fee paid on contract interaction
    pub fee_volume: Variable,
    /// The direction of the relayer fee, will be Buy for the relayer's note
    pub fee_direction: Variable,
    /// The note type, indicating whether this note was generated by transfer
    /// or by match
    pub type_: Variable,
    /// The randomness included with the note, used to authenticate notes
    pub randomness: Variable,
}

impl From<NoteVar> for Vec<Variable> {
    fn from(note: NoteVar) -> Self {
        vec![
            note.mint1,
            note.volume1,
            note.direction1,
            note.mint2,
            note.volume2,
            note.direction2,
            note.fee_mint,
            note.fee_volume,
            note.fee_direction,
            note.type_,
            note.randomness,
        ]
    }
}

/// Represents a note that has been allocated in a constraint system
#[derive(Copy, Clone, Debug, Serialize, Deserialize)]
pub struct CommittedNote {
    /// The first mint exchanged via the note
    pub mint1: CompressedRistretto,
    /// The volume of the first mint exchanged  
    pub volume1: CompressedRistretto,
    /// The direction of the first mint
    pub direction1: CompressedRistretto,
    /// The second mint exchanged via the note
    pub mint2: CompressedRistretto,
    /// The volume of the second mint exchanged
    pub volume2: CompressedRistretto,
    /// The direction of the second mint
    pub direction2: CompressedRistretto,
    /// The mint of the relayer fee paid on contract interaction
    pub fee_mint: CompressedRistretto,
    /// The volume of the relayer fee paid on contract interaction
    pub fee_volume: CompressedRistretto,
    /// The direction of the relayer fee, will be Buy for the relayer's note
    pub fee_direction: CompressedRistretto,
    /// The note type, indicating whether this note was generated by transfer
    /// or by match
    pub type_: CompressedRistretto,
    /// The randomness included with the note, used to authenticate notes
    pub randomness: CompressedRistretto,
}

impl CommitProver for Note {
    type VarType = NoteVar;
    type CommitType = CommittedNote;
    type ErrorType = ();

    fn commit_prover<R: rand_core::RngCore + rand_core::CryptoRng>(
        &self,
        rng: &mut R,
        prover: &mut Prover,
    ) -> Result<(Self::VarType, Self::CommitType), Self::ErrorType> {
        let (mint1_comm, mint1_var) =
            prover.commit(biguint_to_scalar(&self.mint1), Scalar::random(rng));
        let (volume1_comm, volume1_var) =
            prover.commit(Scalar::from(self.volume1), Scalar::random(rng));
        let (direction1_comm, direction1_var) =
            prover.commit(Scalar::from(self.direction1 as u8), Scalar::random(rng));
        let (mint2_comm, mint2_var) =
            prover.commit(biguint_to_scalar(&self.mint2), Scalar::random(rng));
        let (volume2_comm, volume2_var) =
            prover.commit(Scalar::from(self.volume2), Scalar::random(rng));
        let (direction2_comm, direction2_var) =
            prover.commit(Scalar::from(self.direction2 as u8), Scalar::random(rng));
        let (fee_mint_comm, fee_mint_var) =
            prover.commit(biguint_to_scalar(&self.fee_mint), Scalar::random(rng));
        let (fee_volume_comm, fee_volume_var) =
            prover.commit(Scalar::from(self.fee_volume), Scalar::random(rng));
        let (fee_direction_comm, fee_direction_var) =
            prover.commit(Scalar::from(self.fee_direction as u8), Scalar::random(rng));
        let (type_comm, type_var) =
            prover.commit(Scalar::from(self.type_ as u8), Scalar::random(rng));
        let (randomness_comm, randomness_var) =
            prover.commit(Scalar::from(self.randomness), Scalar::random(rng));

        Ok((
            NoteVar {
                mint1: mint1_var,
                volume1: volume1_var,
                direction1: direction1_var,
                mint2: mint2_var,
                volume2: volume2_var,
                direction2: direction2_var,
                fee_mint: fee_mint_var,
                fee_volume: fee_volume_var,
                fee_direction: fee_direction_var,
                type_: type_var,
                randomness: randomness_var,
            },
            CommittedNote {
                mint1: mint1_comm,
                volume1: volume1_comm,
                direction1: direction1_comm,
                mint2: mint2_comm,
                volume2: volume2_comm,
                direction2: direction2_comm,
                fee_mint: fee_mint_comm,
                fee_volume: fee_volume_comm,
                fee_direction: fee_direction_comm,
                type_: type_comm,
                randomness: randomness_comm,
            },
        ))
    }
}

impl CommitVerifier for CommittedNote {
    type VarType = NoteVar;
    type ErrorType = ();

    fn commit_verifier(&self, verifier: &mut Verifier) -> Result<Self::VarType, Self::ErrorType> {
        let mint1_var = verifier.commit(self.mint1);
        let volume1_var = verifier.commit(self.volume1);
        let direction1_var = verifier.commit(self.direction1);
        let mint2_var = verifier.commit(self.mint2);
        let volume2_var = verifier.commit(self.volume2);
        let direction2_var = verifier.commit(self.direction2);
        let fee_mint_var = verifier.commit(self.fee_mint);
        let fee_volume_var = verifier.commit(self.fee_volume);
        let fee_direction_var = verifier.commit(self.fee_direction);
        let type_var = verifier.commit(self.type_);
        let randomness_var = verifier.commit(self.randomness);

        Ok(NoteVar {
            mint1: mint1_var,
            volume1: volume1_var,
            direction1: direction1_var,
            mint2: mint2_var,
            volume2: volume2_var,
            direction2: direction2_var,
            fee_mint: fee_mint_var,
            fee_volume: fee_volume_var,
            fee_direction: fee_direction_var,
            type_: type_var,
            randomness: randomness_var,
        })
    }
}
