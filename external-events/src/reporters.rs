use ring_channel::{ring_channel, RingReceiver};
use serde::{Deserialize, Serialize};
use std::num::NonZeroUsize;

use crate::{errors::ReporterError, exchanges::Exchange, tokens::Token};

/// The PriceReport is the universal format for price feeds from all external exchanges.
#[derive(Clone, Debug, Default, Copy, Serialize, Deserialize)]
pub struct PriceReport {
    /// The midpoint price of the exchange's order book.
    pub midpoint_price: f32,
    /// The time that this update was received by the relayer node.
    pub local_timestamp: u128,
    /// The time that this update was generated by the exchange, if available.
    pub reported_timestamp: Option<u128>,
}

/// The PriceReporter is responsible for opening a websocket connection to the specified exchange,
/// translating messages into PriceReport's, and reporting recent prices.
#[derive(Clone, Debug)]
pub struct PriceReporter {
    pub exchange: Exchange,
    pub quote_token: Token,
    pub base_token: Token,
    /// Ring buffer of PriceReports, for cross-thread communication between websocket stream and
    /// price report consumer(s).
    price_report_receiver: RingReceiver<PriceReport>,
    /// The current PriceReport.
    price_report_latest: PriceReport,
}

impl PriceReporter {
    /// Given a token pair and exchange identifier, create a new PriceReporter.
    pub fn new(
        quote_token: Token,
        base_token: Token,
        exchange: Exchange,
    ) -> Result<Self, ReporterError> {
        let (mut price_report_sender, price_report_receiver) =
            ring_channel::<PriceReport>(NonZeroUsize::new(1).unwrap());
        exchange.setup_exchange_connection(price_report_sender)?;
        Ok(Self {
            exchange,
            quote_token,
            base_token,
            price_report_receiver,
            price_report_latest: PriceReport::default(),
        })
    }

    /// Nonblocking report of the latest price. Tries to read from the ring buffer; if a new
    /// message exists, update the current price_report.
    pub fn get_current_report(&mut self) -> Result<PriceReport, ReporterError> {
        let price_report_recv = self.price_report_receiver.try_recv();
        if price_report_recv.is_ok() {
            self.price_report_latest = price_report_recv.unwrap();
        }
        Ok(self.price_report_latest)
    }
}

/// The MedianPriceReporter is reponsible for creating PriceReporter's for each individual
/// supported exchange, and aggregating prices into a global median.
pub struct MedianPriceReporter {
    pub quote_token: Token,
    pub base_token: Token,
}
