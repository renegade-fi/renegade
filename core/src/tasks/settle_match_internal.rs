//! A task akin to `settle_match`, but on a match that was generated by the internal
//! matching engine

use std::fmt::{Display, Formatter, Result as FmtResult};

use crate::{
    gossip_api::gossip::GossipOutbound, proof_generation::jobs::ProofManagerJob,
    starknet_client::client::StarknetClient, state::RelayerState,
};

use super::driver::{StateWrapper, Task};
use async_trait::async_trait;
use crossbeam::channel::Sender as CrossbeamSender;
use serde::Serialize;
use tokio::sync::mpsc::UnboundedSender as TokioSender;

// -------------
// | Constants |
// -------------

/// The name of the task
pub const SETTLE_MATCH_INTERNAL_TASK_NAME: &str = "settle-match-internal";

// -------------------
// | Task Definition |
// -------------------

/// Describe the settle match internal task
pub struct SettleMatchInternalTask {
    /// The starknet client to use for submitting transactions
    pub starknet_client: StarknetClient,
    /// A sender to the network manager's work queue
    pub network_sender: TokioSender<GossipOutbound>,
    /// A copy of the relayer-global state
    pub global_state: RelayerState,
    /// The work queue to add proof management jobs to
    pub proof_manager_work_queue: CrossbeamSender<ProofManagerJob>,
    /// The state of the task
    pub task_state: SettleMatchInternalTaskState,
}

/// The state of the settle match internal task
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchInternalTaskState {
    /// The task is awaiting scheduling
    Pending,
    /// The task is proving `VALID MATCH MPC` as a singleprover circuit
    ProvingMatch,
    /// The task is proving `VALID SETTLE`
    ProvingSettle,
    /// The task is submitting the match transaction
    SubmittingMatch,
    /// The task is updating the wallet state and Merkle openings
    UpdatingState,
    /// The task is updating validity proofs for the wallet
    UpdatingValidityProofs,
    /// The task has finished
    Completed,
}

impl From<SettleMatchInternalTaskState> for StateWrapper {
    fn from(value: SettleMatchInternalTaskState) -> Self {
        Self::SettleMatchInternal(value)
    }
}

impl Display for SettleMatchInternalTaskState {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}

/// The error type that the task emits
#[derive(Clone, Debug, Serialize)]
pub enum SettleMatchInternalTaskError {}

impl Display for SettleMatchInternalTaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "{self:?}")
    }
}

#[async_trait]
impl Task for SettleMatchInternalTask {
    type State = SettleMatchInternalTaskState;
    type Error = SettleMatchInternalTaskError;

    async fn step(&mut self) -> Result<(), Self::Error> {
        // Dispatch based on the current task state
        match self.state() {
            SettleMatchInternalTaskState::Pending => {
                self.task_state = SettleMatchInternalTaskState::ProvingMatch
            }

            SettleMatchInternalTaskState::ProvingMatch => {
                self.prove_match_mpc().await?;
                self.task_state = SettleMatchInternalTaskState::ProvingSettle
            }

            SettleMatchInternalTaskState::ProvingSettle => {
                self.prove_settle().await?;
                self.task_state = SettleMatchInternalTaskState::SubmittingMatch
            }

            SettleMatchInternalTaskState::SubmittingMatch => {
                self.submit_match().await?;
                self.task_state = SettleMatchInternalTaskState::UpdatingState
            }

            SettleMatchInternalTaskState::UpdatingState => {
                self.update_state().await?;
                self.task_state = SettleMatchInternalTaskState::UpdatingValidityProofs
            }

            SettleMatchInternalTaskState::UpdatingValidityProofs => {
                self.update_proofs().await?;
                self.task_state = SettleMatchInternalTaskState::Completed
            }

            SettleMatchInternalTaskState::Completed => {
                panic!("step called on completed task")
            }
        };

        Ok(())
    }

    fn name(&self) -> String {
        SETTLE_MATCH_INTERNAL_TASK_NAME.to_string()
    }

    fn completed(&self) -> bool {
        matches!(self.task_state, SettleMatchInternalTaskState::Completed)
    }

    fn state(&self) -> Self::State {
        self.task_state.clone().into()
    }
}

// -----------------------
// | Task Implementation |
// -----------------------

impl SettleMatchInternalTask {
    /// Constructor
    pub fn new(
        starknet_client: StarknetClient,
        network_sender: TokioSender<GossipOutbound>,
        global_state: RelayerState,
        proof_manager_work_queue: CrossbeamSender<ProofManagerJob>,
    ) -> Self {
        Self {
            starknet_client,
            network_sender,
            global_state,
            proof_manager_work_queue,
            task_state: SettleMatchInternalTaskState::Pending,
        }
    }

    /// Prove `VALID MATCH MPC` on the order pair
    async fn prove_match_mpc(&self) -> Result<(), SettleMatchInternalTaskError> {
        todo!()
    }

    /// Prove `VALID SETTLE` on the order pair
    async fn prove_settle(&self) -> Result<(), SettleMatchInternalTaskError> {
        todo!()
    }

    /// Submit the match transaction
    async fn submit_match(&self) -> Result<(), SettleMatchInternalTaskError> {
        todo!()
    }

    /// Update the wallet state and Merkle openings
    async fn update_state(&self) -> Result<(), SettleMatchInternalTaskError> {
        todo!()
    }

    /// Update validity proofs for the wallet
    async fn update_proofs(&self) -> Result<(), SettleMatchInternalTaskError> {
        todo!()
    }
}
